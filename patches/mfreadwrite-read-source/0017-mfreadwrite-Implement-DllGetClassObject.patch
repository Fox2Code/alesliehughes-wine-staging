From f6deed1f424b9a617173648fab119a4145a582d5 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 4 Jan 2019 11:42:18 +1100
Subject: [PATCH] mfreadwrite: Implement DllGetClassObject

TODO - Create the MFReadWriteClassFactory.

---
 dlls/mfreadwrite/main.c | 96 +++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 94 insertions(+), 2 deletions(-)

diff --git a/dlls/mfreadwrite/main.c b/dlls/mfreadwrite/main.c
index ae725f8..1fa1323 100644
--- a/dlls/mfreadwrite/main.c
+++ b/dlls/mfreadwrite/main.c
@@ -32,6 +32,8 @@
 #include "wine/heap.h"
 #include "wine/debug.h"
 
+DEFINE_GUID(CLSID_MFReadWriteClassFactory, 0x48e2ed0f, 0x98c2, 0x4a37, 0xbe, 0xd5, 0x16, 0x63, 0x12, 0xdd, 0xd8, 0x3f);
+
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
 static HINSTANCE instance;
@@ -51,10 +53,100 @@ BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD reason, LPVOID reserved)
     return TRUE;
 }
 
+typedef HRESULT (*ClassFactoryCreateInstanceFunc)(void**);
+
+typedef struct
+{
+    IClassFactory IClassFactory_iface;
+    ClassFactoryCreateInstanceFunc pCreateInstance;
+} ClassFactory;
+
+static inline ClassFactory *ClassFactory_from_IClassFactory(IClassFactory *iface)
+{
+    return CONTAINING_RECORD(iface, ClassFactory, IClassFactory_iface);
+}
+
+static HRESULT WINAPI ClassFactory_QueryInterface(IClassFactory *iface, REFIID riid, void **out )
+{
+    if (IsEqualGUID(riid, &IID_IUnknown) ||
+        IsEqualGUID(riid, &IID_IClassFactory))
+    {
+        IClassFactory_AddRef( iface );
+        *out = iface;
+        return S_OK;
+    }
+
+    FIXME("interface %s not implemented\n", debugstr_guid(riid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ClassFactory_AddRef(IClassFactory *iface )
+{
+    return 2;
+}
+
+static ULONG WINAPI ClassFactory_Release(IClassFactory *iface )
+{
+    return 1;
+}
+
+static HRESULT WINAPI ClassFactory_CreateInstance(IClassFactory *iface, IUnknown *outer, REFIID riid, void **out )
+{
+    ClassFactory *This = ClassFactory_from_IClassFactory(iface);
+    IUnknown *punk;
+    HRESULT r;
+
+    TRACE("%p %s %p\n", outer, debugstr_guid(riid), out );
+
+    *out = NULL;
+
+    r = This->pCreateInstance( (void**) &punk );
+    if (FAILED(r))
+        return r;
+
+    r = IUnknown_QueryInterface( punk, riid, out );
+    IUnknown_Release( punk );
+    return r;
+}
+
+static HRESULT WINAPI ClassFactory_LockServer(IClassFactory *iface, BOOL dolock)
+{
+    FIXME("(%p)->(%d),stub!\n",iface,dolock);
+    return S_OK;
+}
+
+static const struct IClassFactoryVtbl ClassFactoryVtbl =
+{
+    ClassFactory_QueryInterface,
+    ClassFactory_AddRef,
+    ClassFactory_Release,
+    ClassFactory_CreateInstance,
+    ClassFactory_LockServer
+};
+
+static HRESULT readwrite_create(void **p)
+{
+    return E_FAIL;
+}
+
+static ClassFactory readwritecf = { { &ClassFactoryVtbl }, readwrite_create };
+
 HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
 {
-    FIXME("(%s,%s,%p)\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
-    return CLASS_E_CLASSNOTAVAILABLE;
+    IClassFactory *cf = NULL;
+
+    TRACE("(%s,%s,%p)\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
+
+    if( IsEqualCLSID( rclsid, &CLSID_MFReadWriteClassFactory ))
+    {
+        cf = &readwritecf.IClassFactory_iface;
+    }
+
+    if ( !cf )
+        return CLASS_E_CLASSNOTAVAILABLE;
+
+    return IClassFactory_QueryInterface( cf, riid, ppv );
 }
 
 HRESULT WINAPI DllCanUnloadNow(void)
-- 
1.9.1

