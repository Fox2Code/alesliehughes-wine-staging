From 1023410fb9c50c486cbd92949f3bb2f5573b61f8 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 15 Jun 2020 16:25:39 +1000
Subject: [PATCH 1/3] winhttp: Implement WinHttpWebSocketSend

WIP
---
 dlls/winhttp/request.c | 168 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 166 insertions(+), 2 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 0511dd44eec..4af50e674e0 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -21,6 +21,7 @@
 
 #include <assert.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <wchar.h>
 
 #define COBJMACROS
@@ -3119,15 +3120,178 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
 
 DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, void *buf, DWORD len )
 {
+    struct socket *sock;
+
+    unsigned char mask[4];
+    unsigned int mask_int;
+    unsigned long long payload_len;
+    unsigned char finNopcode;
+    unsigned int payload_len_small;
+    unsigned int payload_offset = 6;
+    unsigned int len_size;
+    unsigned int sent = 0;
+    unsigned int frame_size;
+    char *data;
+    int i;
+
     FIXME("%p, %u, %p, %u\n", hsocket, type, buf, len);
-    return ERROR_INVALID_PARAMETER;
+
+    if (!(sock = (struct socket *)grab_object( hsocket )))
+    {
+        ERR("Invalid Handle\n");
+        return ERROR_INVALID_OPERATION;
+    }
+
+    if (sock->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
+    {
+        ERR("Incorrect handle\n");
+        release_object( &sock->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
+    }
+
+    finNopcode = 0x80; /* FIN - Final Packet */
+
+    switch (type)
+    {
+        case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE:
+        case WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE:
+            finNopcode |= 0x02;
+            break;
+        case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:
+        case WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE:
+            finNopcode |= 0x01;
+            break;
+
+        case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:
+        default:
+            ERR("Invalid type code %u\n", type);
+            return ERROR_INVALID_PARAMETER;
+    }
+
+    srand(time(NULL));
+    mask_int = rand();
+    memcpy(mask, &mask_int, 4);
+    payload_len = len;
+
+    if(payload_len <= 125) {
+            frame_size = 6 + payload_len;
+            payload_len_small = payload_len;
+
+    } else if(payload_len > 125 && payload_len <= UINT16_MAX) {
+            frame_size = 8 + payload_len;
+            payload_len_small = 126;
+            payload_offset += 2;
+    } else if(payload_len > 0xffff && payload_len <= UINT64_MAX) {
+            frame_size = 14 + payload_len;
+            payload_len_small = 127;
+            payload_offset += 8;
+    } else {
+            return -1;
+    }
+
+    data = (char *)heap_alloc_zero(frame_size);
+
+    *data = finNopcode;
+    *(data+1) = payload_len_small | 0x80; //payload length with mask bit on
+    if(payload_len_small == 126) {
+            payload_len &= UINT16_MAX;
+            len_size = 2;
+            for(i = 0; i < len_size; i++) {
+                    *(data+2+i) = *((char *)&payload_len+(len_size-i-1));
+            }
+    }
+    if(payload_len_small == 127) {
+            payload_len &= UINT64_MAX;
+            len_size = 8;
+            for(i = 0; i < len_size; i++) {
+                    *(data+2+i) = *((char *)&payload_len+(len_size-i-1));
+            }
+    }
+    for(i=0;i<4;i++)
+            *(data+(payload_offset-4)+i) = mask[i];
+
+    memcpy(data+payload_offset, buf, len);
+    for(i=0;i<len;i++)
+        *(data+payload_offset+i) ^= mask[i % 4] & 0xff;
+    sent = 0;
+    i = 0;
+    while(sent < frame_size && i >= 0) {
+            netconn_send(sock->request->netconn, data+sent, frame_size - sent, &i);
+            sent += i;
+    }
+    heap_free(data);
+
+    return 0;
 }
 
+struct webheader
+{
+    unsigned char fin;
+    /*unsigned char resv1:1;
+    unsigned char resv2:1;
+    unsigned char resv3:1;*/
+
+    unsigned char opcode;
+    unsigned char mask;
+    unsigned char lenght;
+};
+
 DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, DWORD *read,
                                       WINHTTP_WEB_SOCKET_BUFFER_TYPE *type )
 {
+    struct socket *sock;
+    struct webheader header;
+    char buffer[1024], *ptr;
+    DWORD /*buf_len,*/ ret;
+    int size;
+
     FIXME("%p, %p, %u, %p, %p\n", hsocket, buf, len, read, type);
-    return ERROR_INVALID_PARAMETER;
+
+    if (!(sock = (struct socket *)grab_object( hsocket )))
+    {
+        ERR("Invalid Handle\n");
+        return ERROR_INVALID_OPERATION;
+    }
+
+    if (sock->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
+    {
+        ERR("Incorrect handle\n");
+        release_object( &sock->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
+    }
+
+    //buf_len = 4096;
+    //buffer = heap_alloc(buf_len);
+
+    ret = netconn_recv( sock->request->netconn, &buffer,
+                        1024, 0, &size );
+
+    ptr = buffer;
+    header.fin = *ptr & 0x80;
+    header.opcode = *ptr & 0x0F;
+
+    ptr++;
+    header.mask = *ptr & 0x80;
+    header.lenght = *ptr & 0x7F;
+
+FIXME("fin    %u\n", header.fin);
+/*FIXME("resv1  %u\n", header.resv1);
+FIXME("resv2  %u\n", header.resv2);
+FIXME("resv3  %u\n", header.resv3);*/
+FIXME("opcode %u\n", header.opcode );
+FIXME("mask   %u\n", header.mask);
+FIXME("lenght %u\n", header.lenght);
+
+    if (header.lenght)
+    {
+        memcpy(buf, ptr, header.lenght);
+    }
+
+    *read = header.lenght;
+
+    *type = WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
+
+    return ret;
 }
 
 DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
-- 
2.27.0

