From 7e46a7f940a3a8bbb26cbda1378a0de5e5cef70e Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 15 Jun 2020 16:25:39 +1000
Subject: [PATCH 2/3] winhttp: Implement WinHttpWebSocketSend

WIP
---
 dlls/winhttp/request.c | 206 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 204 insertions(+), 2 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 08e9d7584ed..bed9677834b 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -21,6 +21,7 @@
 
 #include <assert.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <wchar.h>
 
 #define COBJMACROS
@@ -3117,15 +3118,216 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
 
 DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, void *buf, DWORD len )
 {
+    struct socket *sock;
+
+    unsigned char mask[4];
+    unsigned int mask_int;
+    unsigned long long payload_len;
+    unsigned char finNopcode;
+    unsigned int payload_len_small;
+    unsigned int payload_offset = 6;
+    unsigned int len_size;
+    unsigned int sent = 0;
+    unsigned int frame_size;
+    char *data;
+    int i;
+
     FIXME("%p, %u, %p, %u\n", hsocket, type, buf, len);
-    return ERROR_INVALID_PARAMETER;
+
+    if (!(sock = (struct socket *)grab_object( hsocket )))
+    {
+        ERR("Invalid Handle\n");
+        return ERROR_INVALID_OPERATION;
+    }
+
+    if (sock->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
+    {
+        ERR("Incorrect handle\n");
+        release_object( &sock->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
+    }
+
+    finNopcode = 0x80; /* FIN - Final Packet */
+
+    switch (type)
+    {
+        case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE:
+        case WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE:
+            finNopcode |= 0x02;
+            break;
+        case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:
+        case WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE:
+            finNopcode |= 0x01;
+            break;
+
+        case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:
+        default:
+            ERR("Invalid type code %u\n", type);
+            return ERROR_INVALID_PARAMETER;
+    }
+
+    if (!RtlGenRandom( &mask_int, sizeof(mask_int) ))
+        return ERROR_INVALID_PARAMETER;
+
+    memcpy(mask, &mask_int, 4);
+    payload_len = len;
+
+    if(payload_len <= 125)
+    {
+        frame_size = 6 + payload_len;
+        payload_len_small = payload_len;
+    }
+    else if(payload_len > 125 && payload_len <= UINT16_MAX)
+    {
+        frame_size = 8 + payload_len;
+        payload_len_small = 126;
+        payload_offset += 2;
+    }
+    else if(payload_len > 0xffff && payload_len <= UINT64_MAX)
+    {
+        frame_size = 14 + payload_len;
+        payload_len_small = 127;
+        payload_offset += 8;
+    }
+    else
+    {
+        ERR("Length out of range\n");
+        return ERROR_INVALID_PARAMETER;
+    }
+
+    data = (char *)heap_alloc_zero(frame_size);
+
+    *data = finNopcode;
+    *(data+1) = 0x80 | payload_len_small;  /* Mask bit and Payload length */
+    if(payload_len_small == 126) {
+        payload_len &= UINT16_MAX;
+        len_size = 2;
+        for(i = 0; i < len_size; i++) {
+                *(data+2+i) = *((char *)&payload_len+(len_size-i-1));
+        }
+    }
+    else if(payload_len_small == 127) {
+        payload_len &= UINT64_MAX;
+        len_size = 8;
+        for(i = 0; i < len_size; i++) {
+                *(data+2+i) = *((char *)&payload_len+(len_size-i-1));
+        }
+    }
+    for(i=0; i< ARRAY_SIZE(mask); i++)
+        *(data+(payload_offset-4)+i) = mask[i];
+
+    memcpy(data+payload_offset, buf, len);
+    for(i=0;i<len;i++)
+        *(data+payload_offset+i) ^= mask[i % 4] & 0xff;
+    sent = 0;
+    i = 0;
+    while(sent < frame_size && i >= 0) {
+        netconn_send(sock->request->netconn, data+sent, frame_size - sent, &i);
+        sent += i;
+    }
+    heap_free(data);
+
+    return 0;
 }
 
+struct webheader
+{
+    unsigned char fin;
+    /*unsigned char resv1:1;
+    unsigned char resv2:1;
+    unsigned char resv3:1;*/
+
+    unsigned char opcode;
+    unsigned char mask;
+    unsigned char length;
+};
+
 DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, DWORD *read,
                                       WINHTTP_WEB_SOCKET_BUFFER_TYPE *type )
 {
+    struct socket *sock;
+    struct webheader header;
+    char buffer[4], *ptr;
+    DWORD /*buf_len,*/ ret;
+    int size;
+    DWORD packetsize;
+
     FIXME("%p, %p, %u, %p, %p\n", hsocket, buf, len, read, type);
-    return ERROR_INVALID_PARAMETER;
+
+    if (!(sock = (struct socket *)grab_object( hsocket )))
+    {
+        ERR("Invalid Handle\n");
+        return ERROR_INVALID_OPERATION;
+    }
+
+    if (sock->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
+    {
+        ERR("Incorrect handle type\n");
+        release_object( &sock->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
+    }
+
+    /* Just Read the header */
+    ret = netconn_recv( sock->request->netconn, &buffer, 2, 0, &size );
+    if (ret != 0)
+    {
+        WARN("recv returned %d\n", ret);
+        release_object( &sock->hdr );
+        return ret;
+    }
+
+    ptr = buffer;
+    header.fin = *ptr & 0x80;
+    header.opcode = *ptr & 0x0F;
+    ptr++;
+
+    header.mask = *ptr & 0x80;
+    header.length = *ptr & 0x7F;
+    ptr++;
+
+FIXME("fin    %u\n", header.fin);
+/*FIXME("resv1  %u\n", header.resv1);
+FIXME("resv2  %u\n", header.resv2);
+FIXME("resv3  %u\n", header.resv3);*/
+FIXME("opcode %u\n", header.opcode );
+FIXME("mask   %u\n", header.mask);
+FIXME("length %u\n", header.length);
+
+    packetsize = header.length;
+    if (header.length == 126)
+    {
+        ret = netconn_recv( sock->request->netconn, &packetsize, 4, 0, &size );
+        if (ret != 0)
+        {
+            WARN("recv returned %d\n", ret);
+            release_object( &sock->hdr );
+            return ret;
+        }
+    }
+    else if (header.length == 127)
+    {
+        /**/
+        ERR("64 length currently not supported.\n");
+        return 1;
+    }
+
+    FIXME("packetsize %u\n", packetsize);
+    ret = netconn_recv( sock->request->netconn, &ptr, packetsize, 0, &size );
+    if (ret != 0)
+    {
+        WARN("recv returned %d\n", ret);
+        release_object( &sock->hdr );
+        return ret;
+    }
+
+    if (read)
+        *read = header.length;
+    if (type)
+        *type = WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
+
+    release_object( &sock->hdr );
+
+    return ret;
 }
 
 DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
-- 
2.27.0

