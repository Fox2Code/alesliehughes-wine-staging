From 1945ecd9cdacea8c2f5f1924898ebc2d03dee48d Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 15 Jun 2020 16:25:39 +1000
Subject: [PATCH 6/7] winhttp: Implement WinHttpWebSocketSend

WIP
---
 dlls/winhttp/request.c | 168 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 165 insertions(+), 3 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index f0553dd6fa1..5e3b9661f87 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3089,15 +3089,177 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
 
 DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, void *buf, DWORD len )
 {
-    FIXME("%p, %u, %p, %u\n", hsocket, type, buf, len);
-    return ERROR_INVALID_PARAMETER;
+    struct request *request;
+
+    char *strdata;
+
+    //struct timeval tv;
+    unsigned char mask[4];
+    unsigned int mask_int;
+    unsigned long long payload_len;
+    unsigned char finNopcode;
+    unsigned int payload_len_small;
+    unsigned int payload_offset = 6;
+    unsigned int len_size;
+    //unsigned long long be_payload_len;
+    unsigned int sent = 0;
+    unsigned int frame_size;
+    char *data;
+    int i;
+
+    TRACE("%p, %u, %p, %u\n", hsocket, type, buf, len);
+
+    if (!(request = (struct request *)grab_object( hsocket )))
+    {
+        return ERROR_INVALID_OPERATION;
+    }
+
+    finNopcode = 0x80; //FIN and text opcode.
+
+    switch (type)
+    {
+        case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE:
+        case WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE:
+            finNopcode |= 0x02;
+            break;
+        case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:
+        case WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE:
+            finNopcode |= 0x01;
+            break;
+
+        case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:
+        default:
+            ERR("Invalid type code %u\n", type);
+            return ERROR_INVALID_PARAMETER;
+    }
+
+    strdata = (char *)heap_alloc(len);
+
+    sprintf(strdata, "%S", buf);
+
+    srand(time(NULL));
+    mask_int = rand();
+    memcpy(mask, &mask_int, 4);
+    payload_len = strlen(strdata);
+
+
+    if(payload_len <= 125) {
+            frame_size = 6 + payload_len;
+            payload_len_small = payload_len;
+
+    } else if(payload_len > 125 && payload_len <= 0xffff) {
+            frame_size = 8 + payload_len;
+            payload_len_small = 126;
+            payload_offset += 2;
+    } else if(payload_len > 0xffff && payload_len <= 0xffffffffffffffffLL) {
+            frame_size = 14 + payload_len;
+            payload_len_small = 127;
+            payload_offset += 8;
+    } else {
+            return -1;
+    }
+    data = (char *)malloc(frame_size);
+    memset(data, 0, frame_size);
+    *data = finNopcode;
+    *(data+1) = payload_len_small | 0x80; //payload length with mask bit on
+    if(payload_len_small == 126) {
+            payload_len &= 0xffff;
+            len_size = 2;
+            for(i = 0; i < len_size; i++) {
+                    *(data+2+i) = *((char *)&payload_len+(len_size-i-1));
+            }
+    }
+    if(payload_len_small == 127) {
+            payload_len &= 0xffffffffffffffffLL;
+            len_size = 8;
+            for(i = 0; i < len_size; i++) {
+                    *(data+2+i) = *((char *)&payload_len+(len_size-i-1));
+            }
+    }
+    for(i=0;i<4;i++)
+            *(data+(payload_offset-4)+i) = mask[i];
+
+    memcpy(data+payload_offset, strdata, strlen(strdata));
+    for(i=0;i<strlen(strdata);i++)
+            *(data+payload_offset+i) ^= mask[i % 4] & 0xff;
+    sent = 0;
+    i = 0;
+    while(sent < frame_size && i >= 0) {
+            netconn_send(request->netconn, data+sent, frame_size - sent, &i);
+            sent += i;
+    }
+    free(data);
+    heap_free(strdata);
+    return 0;
 }
 
+struct webheader
+{
+    unsigned char fin;
+    /*unsigned char resv1:1;
+    unsigned char resv2:1;
+    unsigned char resv3:1;*/
+
+    unsigned char opcode;
+    unsigned char mask;
+    unsigned char lenght;
+};
+
 DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, DWORD *read,
                                       WINHTTP_WEB_SOCKET_BUFFER_TYPE *type )
 {
+    struct request *request;
+    struct webheader header;
+    char buffer[1024], *ptr;
+    DWORD /*buf_len,*/ ret;
+    int size;
+
     FIXME("%p, %p, %u, %p, %p\n", hsocket, buf, len, read, type);
-    return ERROR_INVALID_PARAMETER;
+
+    if (!(request = (struct request *)grab_object( hsocket )))
+    {
+        return 11;
+    }
+
+    //buf_len = 4096;
+    //buffer = heap_alloc(buf_len);
+
+    ret = netconn_recv( request->netconn, &buffer,
+                        1024, 0, &size );
+
+    ptr = buffer;
+    header.fin = *ptr & 0x80;
+    header.opcode = *ptr & 0x0F;
+
+    ptr++;
+    header.mask = *ptr & 0x80;
+    header.lenght = *ptr & 0x7F;
+
+FIXME("fin    %u\n", header.fin);
+/*FIXME("resv1  %u\n", header.resv1);
+FIXME("resv2  %u\n", header.resv2);
+FIXME("resv3  %u\n", header.resv3);*/
+FIXME("opcode %u\n", header.opcode );
+FIXME("mask   %u\n", header.mask);
+FIXME("lenght %u\n", header.lenght);
+
+    ptr++;
+
+FIXME("strings %s\n", debugstr_a( ptr) );
+    if (header.lenght < 126)
+    {
+            int ddd;
+            // TODO - If TEXT
+            ddd = MultiByteToWideChar( CP_ACP, 0, ptr, header.lenght, NULL, 0 );
+            MultiByteToWideChar( CP_ACP, 0, ptr, header.lenght, buf, ddd );
+            ((WCHAR*)buf)[ddd] = 0;
+    }
+
+    *read = header.lenght;
+
+    *type = WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
+
+    return ret;
 }
 
 DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
-- 
2.27.0

