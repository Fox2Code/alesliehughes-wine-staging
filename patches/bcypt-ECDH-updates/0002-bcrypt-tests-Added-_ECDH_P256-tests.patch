From 8889d5ba79ef6e345857274d504ca9aad462b327 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 15 Jun 2018 10:06:40 +1000
Subject: [PATCH 2/2] bcrypt/tests: Added _ECDH_P256 tests

---
 dlls/bcrypt/tests/bcrypt.c | 79 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 79 insertions(+)

diff --git a/dlls/bcrypt/tests/bcrypt.c b/dlls/bcrypt/tests/bcrypt.c
index 6865e87..e06376a 100644
--- a/dlls/bcrypt/tests/bcrypt.c
+++ b/dlls/bcrypt/tests/bcrypt.c
@@ -24,6 +24,7 @@
 #include <windows.h>
 #include <bcrypt.h>
 
+#include "wine/heap.h"
 #include "wine/test.h"
 
 static NTSTATUS (WINAPI *pBCryptOpenAlgorithmProvider)(BCRYPT_ALG_HANDLE *, LPCWSTR, LPCWSTR, ULONG);
@@ -35,8 +36,10 @@ static NTSTATUS (WINAPI *pBCryptHash)(BCRYPT_ALG_HANDLE, UCHAR *, ULONG, UCHAR *
 static NTSTATUS (WINAPI *pBCryptHashData)(BCRYPT_HASH_HANDLE, PUCHAR, ULONG, ULONG);
 static NTSTATUS (WINAPI *pBCryptDuplicateHash)(BCRYPT_HASH_HANDLE, BCRYPT_HASH_HANDLE *, UCHAR *, ULONG, ULONG);
 static NTSTATUS (WINAPI *pBCryptFinishHash)(BCRYPT_HASH_HANDLE, PUCHAR, ULONG, ULONG);
+static NTSTATUS (WINAPI *pBCryptFinalizeKeyPair)(BCRYPT_KEY_HANDLE, ULONG);
 static NTSTATUS (WINAPI *pBCryptDestroyHash)(BCRYPT_HASH_HANDLE);
 static NTSTATUS (WINAPI *pBCryptGenRandom)(BCRYPT_ALG_HANDLE, PUCHAR, ULONG, ULONG);
+static NTSTATUS (WINAPI *pBCryptGenerateKeyPair)(BCRYPT_ALG_HANDLE, BCRYPT_KEY_HANDLE *, ULONG, ULONG);
 static NTSTATUS (WINAPI *pBCryptGetProperty)(BCRYPT_HANDLE, LPCWSTR, PUCHAR, ULONG, ULONG *, ULONG);
 static NTSTATUS (WINAPI *pBCryptSetProperty)(BCRYPT_HANDLE, LPCWSTR, PUCHAR, ULONG, ULONG);
 static NTSTATUS (WINAPI *pBCryptGenerateSymmetricKey)(BCRYPT_ALG_HANDLE, BCRYPT_KEY_HANDLE *, PUCHAR, ULONG,
@@ -1610,6 +1613,79 @@ static void test_RSA(void)
     ok(!ret, "pBCryptCloseAlgorithmProvider failed: %08x\n", ret);
 }
 
+static void test_ECDH(void)
+{
+    BCRYPT_ALG_HANDLE alg = NULL;
+    BCRYPT_KEY_HANDLE key = NULL;
+    NTSTATUS ret;
+    ULONG size = 0;
+    UCHAR  *publickey;
+
+    ret = pBCryptOpenAlgorithmProvider(&alg, BCRYPT_ECDH_P256_ALGORITHM, MS_PRIMITIVE_PROVIDER, 0);
+    if (ret)
+    {
+        win_skip("Failed to open ECDH provider: %08x, skipping test\n", ret);
+        return;
+    }
+
+    ret = pBCryptGenerateKeyPair(alg, &key, 256, 0);
+    ok(!ret, "BCryptGenerateKeyPair failed: %08x\n", ret);
+
+    ret = pBCryptFinalizeKeyPair(key, 0);
+    ok(!ret, "BCryptImportKeyPair failed: %08x\n", ret);
+
+    ret = pBCryptExportKey(key, NULL, BCRYPT_ECCPUBLIC_BLOB, NULL, 0, &size, 0);
+    ok(!ret, "BCryptExportKey failed: %08x\n", ret);
+
+    publickey = heap_alloc(size);
+
+    ret = pBCryptExportKey(key, NULL, BCRYPT_ECCPUBLIC_BLOB, publickey, size, &size, 0);
+    ok(!ret, "BCryptExportKey failed: %08x\n", ret);
+    trace("size %d\n", size);
+
+/*
+res = BCryptGenerateKeyPair(aliceCryptHandle, &aliceKey, 384, 0);
+		if (0 != res){PrintErrorMessage(res, _T("BCryptGenerateKeyPair"));return;}
+
+		res = BCryptFinalizeKeyPair(aliceKey, 0);
+		if (0 != res){PrintErrorMessage(res, _T("BCryptFinalizeKeyPair"));return;}
+
+		res = BCryptExportKey(aliceKey, NULL, BCRYPT_ECCPUBLIC_BLOB, NULL, 0, &alicesPublicKeySize, 0);
+		if (0 != res){PrintErrorMessage(res, _T("BCryptExportKey 1"));return;}
+		alicePublicKey = new UCHAR[alicesPublicKeySize];
+		res = BCryptExportKey(aliceKey, NULL, BCRYPT_ECCPUBLIC_BLOB, alicePublicKey, alicesPublicKeySize, &alicesPublicKeySize, 0);
+		if (0 != res){PrintErrorMessage(res, _T("BCryptExportKey 2"));return;}
+*/
+    /*pad.pszAlgId = BCRYPT_SHA1_ALGORITHM;
+    ret = pBCryptVerifySignature(key, &pad, rsaHash, sizeof(rsaHash), rsaSignature, sizeof(rsaSignature), BCRYPT_PAD_PKCS1);
+    ok(!ret, "pBCryptVerifySignature failed: %08x\n", ret);
+
+    ret = pBCryptVerifySignature(key, NULL, rsaHash, sizeof(rsaHash), rsaSignature, sizeof(rsaSignature), BCRYPT_PAD_PKCS1);
+    ok(ret == STATUS_INVALID_PARAMETER, "Expected STATUS_INVALID_PARAMETER, got %08x\n", ret);
+
+    pad.pszAlgId = BCRYPT_SHA1_ALGORITHM;
+    ret = pBCryptVerifySignature(key, &pad, rsaHash, sizeof(rsaHash), rsaSignature, sizeof(rsaSignature), 0);
+    ok(ret == STATUS_INVALID_PARAMETER, "Expected STATUS_INVALID_PARAMETER, got %08x\n", ret);
+
+    ret = pBCryptVerifySignature(key, NULL, rsaHash, sizeof(rsaHash), rsaSignature, sizeof(rsaSignature), 0);
+    ok(ret == STATUS_INVALID_PARAMETER, "Expected STATUS_INVALID_PARAMETER, got %08x\n", ret);
+
+    pad.pszAlgId = BCRYPT_AES_ALGORITHM;
+    ret = pBCryptVerifySignature(key, &pad, rsaHash, sizeof(rsaHash), rsaSignature, sizeof(rsaSignature), BCRYPT_PAD_PKCS1);
+    ok(ret == STATUS_NOT_SUPPORTED, "Expected STATUS_NOT_SUPPORTED, got %08x\n", ret);
+
+    pad.pszAlgId = NULL;
+    ret = pBCryptVerifySignature(key, &pad, rsaHash, sizeof(rsaHash), rsaSignature, sizeof(rsaSignature), BCRYPT_PAD_PKCS1);
+    ok(ret == STATUS_INVALID_SIGNATURE, "Expected STATUS_INVALID_SIGNATURE, got %08x\n", ret);
+*/
+
+    ret = pBCryptDestroyKey(key);
+    ok(!ret, "pBCryptDestroyKey failed: %08x\n", ret);
+
+    ret = pBCryptCloseAlgorithmProvider(alg, 0);
+    ok(!ret, "pBCryptCloseAlgorithmProvider failed: %08x\n", ret);
+}
+
 START_TEST(bcrypt)
 {
     HMODULE module;
@@ -1629,10 +1705,12 @@ START_TEST(bcrypt)
     pBCryptHashData = (void *)GetProcAddress(module, "BCryptHashData");
     pBCryptDuplicateHash = (void *)GetProcAddress(module, "BCryptDuplicateHash");
     pBCryptFinishHash = (void *)GetProcAddress(module, "BCryptFinishHash");
+    pBCryptFinalizeKeyPair = (void *)GetProcAddress(module, "BCryptFinalizeKeyPair");
     pBCryptDestroyHash = (void *)GetProcAddress(module, "BCryptDestroyHash");
     pBCryptGenRandom = (void *)GetProcAddress(module, "BCryptGenRandom");
     pBCryptGetProperty = (void *)GetProcAddress(module, "BCryptGetProperty");
     pBCryptSetProperty = (void *)GetProcAddress(module, "BCryptSetProperty");
+    pBCryptGenerateKeyPair = (void *)GetProcAddress(module, "BCryptGenerateKeyPair");
     pBCryptGenerateSymmetricKey = (void *)GetProcAddress(module, "BCryptGenerateSymmetricKey");
     pBCryptEncrypt = (void *)GetProcAddress(module, "BCryptEncrypt");
     pBCryptDecrypt = (void *)GetProcAddress(module, "BCryptDecrypt");
@@ -1654,6 +1732,7 @@ START_TEST(bcrypt)
     test_key_import_export();
     test_ECDSA();
     test_RSA();
+    test_ECDH();
 
     if (pBCryptHash) /* >= Win 10 */
         test_BcryptHash();
-- 
1.9.1

