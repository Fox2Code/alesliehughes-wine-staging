From db2c82e2a60860f485ba1d23d072773bff551006 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 17 Dec 2015 11:09:39 +1100
Subject: [PATCH 04/12] msad015: Add stubbed _Connection interface

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/msado15/Makefile.in  |   4 +-
 dlls/msado15/connection.c | 448 ++++++++++++++++++++++++++++++++++++++++++++++
 dlls/msado15/msado15.c    | 105 ++++++++++-
 3 files changed, 553 insertions(+), 4 deletions(-)
 create mode 100644 dlls/msado15/connection.c

diff --git a/dlls/msado15/Makefile.in b/dlls/msado15/Makefile.in
index 0a98cc6..c24f305 100644
--- a/dlls/msado15/Makefile.in
+++ b/dlls/msado15/Makefile.in
@@ -1,6 +1,8 @@
 MODULE    = msado15.dll
 
 
-C_SRCS = msado15.c
+C_SRCS = \
+	connection.c \
+	msado15.c
 
 IDL_SRCS = msado15_typelib.idl
diff --git a/dlls/msado15/connection.c b/dlls/msado15/connection.c
new file mode 100644
index 0000000..0bf506f
--- /dev/null
+++ b/dlls/msado15/connection.c
@@ -0,0 +1,448 @@
+/*
+ * Copyright 2015 Alistair Leslie-Hughes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define COBJMACROS
+
+#include "config.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "ole2.h"
+
+#include "wine/debug.h"
+
+#include "msado15.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(msado);
+
+/* Move these to private header */
+static inline void *heap_alloc(size_t len)
+{
+    return HeapAlloc(GetProcessHeap(), 0, len);
+}
+
+
+static inline BOOL heap_free(void *mem)
+{
+    return HeapFree(GetProcessHeap(), 0, mem);
+}
+
+typedef struct
+{
+    _Connection _Connection_iface;
+
+    LONG ref;
+} connection;
+
+
+static inline connection *impl_from_Connection(_Connection *iface)
+{
+    return CONTAINING_RECORD(iface, connection, _Connection_iface);
+}
+
+
+static HRESULT WINAPI connection_QueryInterface(_Connection *iface, REFIID riid, void **out)
+{
+    connection *This = impl_from_Connection(iface);
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), out);
+
+    *out = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown)    ||
+       IsEqualIID(riid, &IID_IDispatch)   ||
+       IsEqualIID(riid, &IID__Connection))
+    {
+        *out = iface;
+    }
+    else
+    {
+        FIXME("interface %s not implemented\n", debugstr_guid(riid));
+        return E_NOINTERFACE;
+    }
+
+    _Connection_AddRef(iface);
+    return S_OK;
+}
+
+static ULONG WINAPI connection_AddRef(_Connection *iface)
+{
+    connection *This = impl_from_Connection(iface);
+    TRACE("(%p)\n", This);
+
+    return InterlockedIncrement(&This->ref);
+}
+
+static ULONG WINAPI connection_Release(_Connection *iface)
+{
+    connection *This = impl_from_Connection(iface);
+    LONG ref;
+
+    TRACE("(%p)\n", This);
+
+    ref = InterlockedDecrement(&This->ref);
+    if(ref == 0)
+        heap_free(This);
+
+    return ref;
+}
+
+static HRESULT WINAPI connection_GetTypeInfoCount(_Connection *iface, UINT *pctinfo)
+{
+    connection *This = impl_from_Connection(iface);
+    TRACE("(%p)->()\n", This);
+
+    *pctinfo = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI connection_GetTypeInfo(_Connection *iface, UINT iTInfo, LCID lcid, ITypeInfo **typeinfo)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%u %u %p)\n", This, iTInfo, lcid, typeinfo);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_GetIDsOfNames(_Connection *iface, REFIID riid, LPOLESTR *rgszNames,
+        UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%s %p %u %u %p)\n", This, debugstr_guid(riid), rgszNames, cNames, lcid, rgDispId);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_Invoke(_Connection *iface, DISPID dispIdMember, REFIID riid,
+        LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
+        UINT *puArgErr)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%d %s %d %d %p %p %p %p)\n", This, dispIdMember, debugstr_guid(riid),
+           lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_Properties(_Connection *iface, Properties **props)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, props);
+
+    return E_NOTIMPL;
+}
+
+
+static HRESULT WINAPI connection_get_ConnectionString(_Connection *iface, BSTR *connectionstring)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, connectionstring);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_put_ConnectionString(_Connection *iface, BSTR connectionstring)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(connectionstring));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_CommandTimeout(_Connection *iface, LONG *timeout)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, timeout);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_put_CommandTimeout(_Connection *iface, LONG timeout)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%d)\n", This, timeout);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_ConnectionTimeout(_Connection *iface, LONG *timeout)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, timeout);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_put_ConnectionTimeout(_Connection *iface, LONG timeout)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%d)\n", This, timeout);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_Version(_Connection *iface, BSTR *version)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, version);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_Close(_Connection *iface)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)\n", This);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_Execute(_Connection *iface, BSTR commandtext, VARIANT *recordsaffected,
+        LONG options, _Recordset **recordset)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p->(%s %p %d %p)\n", This, debugstr_w(commandtext), recordsaffected, options, recordset);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_BeginTrans(_Connection *iface, LONG *transactionlevel)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, transactionlevel);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_CommitTrans(_Connection *iface)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)\n", This);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_RollbackTrans(_Connection *iface)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)\n", This);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_Open(_Connection *iface, BSTR connectionstring, BSTR userid,
+        BSTR password, LONG options)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%s %s %s %d)\n", This, debugstr_w(connectionstring), debugstr_w(userid),
+	        debugstr_w(password), options);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_Errors(_Connection *iface, Errors **errors)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, errors);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_DefaultDatabase(_Connection *iface, BSTR *defaultdb)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, defaultdb);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_put_DefaultDatabase(_Connection *iface, BSTR defaultdb)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(defaultdb));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_IsolationLevel(_Connection *iface, IsolationLevelEnum *level)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, level);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_put_IsolationLevel(_Connection *iface, IsolationLevelEnum level)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%d)\n", This, level);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_Attributes(_Connection *iface, LONG *attributes)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_put_Attributes(_Connection *iface, LONG attributes)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%d)\n", This, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_CursorLocation(_Connection *iface, CursorLocationEnum *cursorloc)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, cursorloc);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_put_CursorLocation(_Connection *iface, CursorLocationEnum cursorloc)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%d)\n", This, cursorloc);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_Mode(_Connection *iface, ConnectModeEnum *mode)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_put_Mode(_Connection *iface, ConnectModeEnum mode)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%d)\n", This, mode);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_Provider(_Connection *iface, BSTR *provider)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, provider);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_put_Provider(_Connection *iface, BSTR provider)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(provider));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_get_State(_Connection *iface, LONG *state)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, state);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_OpenSchema(_Connection *iface, SchemaEnum schema, VARIANT restrictions,
+        VARIANT schemaid, _Recordset **recordset)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)->(%p)\n", This, recordset);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI connection_Cancel(_Connection *iface)
+{
+    connection *This = impl_from_Connection(iface);
+    FIXME("(%p)\n", This);
+
+    return E_NOTIMPL;
+}
+
+
+static const struct _ConnectionVtbl connection_vtbl =
+{
+    connection_QueryInterface,
+    connection_AddRef,
+    connection_Release,
+    connection_GetTypeInfoCount,
+    connection_GetTypeInfo,
+    connection_GetIDsOfNames,
+    connection_Invoke,
+    connection_get_Properties,
+    connection_get_ConnectionString,
+    connection_put_ConnectionString,
+    connection_get_CommandTimeout,
+    connection_put_CommandTimeout,
+    connection_get_ConnectionTimeout,
+    connection_put_ConnectionTimeout,
+    connection_get_Version,
+    connection_Close,
+    connection_Execute,
+    connection_BeginTrans,
+    connection_CommitTrans,
+    connection_RollbackTrans,
+    connection_Open,
+    connection_get_Errors,
+    connection_get_DefaultDatabase,
+    connection_put_DefaultDatabase,
+    connection_get_IsolationLevel,
+    connection_put_IsolationLevel,
+    connection_get_Attributes,
+    connection_put_Attributes,
+    connection_get_CursorLocation,
+    connection_put_CursorLocation,
+    connection_get_Mode,
+    connection_put_Mode,
+    connection_get_Provider,
+    connection_put_Provider,
+    connection_get_State,
+    connection_OpenSchema,
+    connection_Cancel
+};
+
+HRESULT Connecton_create(void **out)
+{
+    connection *This;
+
+    TRACE("(%p)\n", out);
+
+    *out = NULL;
+
+    This = heap_alloc(sizeof(*This));
+    if (!This)
+	    return E_OUTOFMEMORY;
+
+    This->_Connection_iface.lpVtbl = &connection_vtbl;
+    This->ref = 1;
+
+    *out = &This->_Connection_iface;
+
+    return S_OK;
+}
\ No newline at end of file
diff --git a/dlls/msado15/msado15.c b/dlls/msado15/msado15.c
index b98a78c..a9289cd 100644
--- a/dlls/msado15/msado15.c
+++ b/dlls/msado15/msado15.c
@@ -15,21 +15,28 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
+#define COBJMACROS
 
 #include "config.h"
 
 #include <stdarg.h>
 
+#include "initguid.h"
 #include "windef.h"
 #include "winbase.h"
 #include "ole2.h"
 #include "rpcproxy.h"
 #include "wine/debug.h"
 
+#include "msado15.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(msado);
 
 static HINSTANCE instance;
 
+typedef HRESULT (*ClassFactoryCreateInstanceFunc)(void**);
+typedef HRESULT (*fnCreateInstance)(REFIID riid, void**ppObj);
+
 BOOL WINAPI DllMain(HINSTANCE hinstance, DWORD reason, void *reserved)
 {
     TRACE("(%p, %u, %p)\n", instance, reason, reserved);
@@ -47,11 +54,103 @@ BOOL WINAPI DllMain(HINSTANCE hinstance, DWORD reason, void *reserved)
     return TRUE;
 }
 
-HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID iid, LPVOID *ppv)
+typedef struct
+{
+    IClassFactory IClassFactory_iface;
+    ClassFactoryCreateInstanceFunc pCreateInstance;
+} ClassFactory;
+
+static inline ClassFactory *ClassFactory_from_IClassFactory(IClassFactory *iface)
 {
-    FIXME("%s %s %p\n", debugstr_guid(rclsid), debugstr_guid(iid), ppv);
+    return CONTAINING_RECORD(iface, ClassFactory, IClassFactory_iface);
+}
+
+static HRESULT WINAPI msadocf_QueryInterface(IClassFactory *iface, REFIID riid, LPVOID *ppobj )
+{
+    TRACE("%s %p\n", debugstr_guid(riid), ppobj);
+
+    if (IsEqualGUID(riid, &IID_IUnknown) ||
+        IsEqualGUID(riid, &IID_IClassFactory))
+    {
+        IClassFactory_AddRef( iface );
+        *ppobj = iface;
+        return S_OK;
+    }
+
+    ERR("interface %s not implemented\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI msadocf_AddRef(IClassFactory *iface )
+{
+    return 2;
+}
+
+static ULONG WINAPI msadocf_Release(IClassFactory *iface )
+{
+    return 1;
+}
+
+static HRESULT WINAPI msadocf_CreateInstance(IClassFactory *iface, IUnknown *outer,
+                            REFIID riid, void **ppobj )
+{
+    ClassFactory *This = ClassFactory_from_IClassFactory(iface);
+    IUnknown *punk;
+    HRESULT r;
+
+    TRACE("%p %s %p\n", outer, debugstr_guid(riid), ppobj );
+
+    *ppobj = NULL;
+
+    if (outer)
+        return CLASS_E_NOAGGREGATION;
+
+    r = This->pCreateInstance( (void**) &punk );
+    if (FAILED(r))
+        return r;
+
+    r = IUnknown_QueryInterface( punk, riid, ppobj );
+    IUnknown_Release( punk );
+    return r;
+}
+
+static HRESULT WINAPI msadocf_LockServer(IClassFactory *iface, BOOL dolock)
+{
+    TRACE("(%p)->(%d),stub!\n",iface,dolock);
+    return S_OK;
+}
+
+static const struct IClassFactoryVtbl msadocf_vtbl =
+{
+    msadocf_QueryInterface,
+    msadocf_AddRef,
+    msadocf_Release,
+    msadocf_CreateInstance,
+    msadocf_LockServer
+};
+
+extern HRESULT Connecton_create(void **out);
+
+static ClassFactory connectioncf = { { &msadocf_vtbl }, Connecton_create };
+
+HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
+{
+    IClassFactory *cf = NULL;
+
+    TRACE("(%s, %s, %p): stub\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_INVALIDARG;
+
+    if (IsEqualCLSID( rclsid, &CLSID_Connection))
+    {
+        cf = &connectioncf.IClassFactory_iface;
+    }
+
+    if (!cf)
+        return CLASS_E_CLASSNOTAVAILABLE;
 
-    return CLASS_E_CLASSNOTAVAILABLE;
+    return IClassFactory_QueryInterface( cf, riid, ppv );
 }
 
 HRESULT WINAPI DllCanUnloadNow(void)
-- 
1.9.1

