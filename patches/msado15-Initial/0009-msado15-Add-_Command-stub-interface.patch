From d1d9a2a19d9752cdb0feca6baf93290ccfb67828 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 4 Jan 2016 15:46:53 +1100
Subject: [PATCH 9/9] msado15: Add _Command stub interface

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/msado15/Makefile.in       |   1 +
 dlls/msado15/command.c         | 391 +++++++++++++++++++++++++++++++++++++++++
 dlls/msado15/msado15.c         |   5 +
 dlls/msado15/msado15_private.h |   3 +-
 4 files changed, 399 insertions(+), 1 deletion(-)
 create mode 100644 dlls/msado15/command.c

diff --git a/dlls/msado15/Makefile.in b/dlls/msado15/Makefile.in
index 505db20..58d78ef 100644
--- a/dlls/msado15/Makefile.in
+++ b/dlls/msado15/Makefile.in
@@ -2,6 +2,7 @@ MODULE    = msado15.dll
 
 
 C_SRCS = \
+	command.c \
 	connection.c \
 	msado15.c \
 	recordset.c
diff --git a/dlls/msado15/command.c b/dlls/msado15/command.c
new file mode 100644
index 0000000..8a709f8
--- /dev/null
+++ b/dlls/msado15/command.c
@@ -0,0 +1,391 @@
+/*
+ * Copyright 2016 Alistair Leslie-Hughes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define COBJMACROS
+
+#include "config.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "ole2.h"
+
+#include "wine/debug.h"
+
+#include "msado15.h"
+#include "msado15_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(msado);
+
+typedef struct
+{
+    _Command _Command_iface;
+
+    LONG ref;
+} command;
+
+
+static inline command *impl_from_Command(_Command *iface)
+{
+    return CONTAINING_RECORD(iface, command, _Command_iface);
+}
+
+static HRESULT WINAPI command_QueryInterface(_Command *iface, REFIID riid, void **out)
+{
+    command *This = impl_from_Command(iface);
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), out);
+
+    *out = NULL;
+
+    if(IsEqualIID(riid, &IID_IUnknown)    ||
+       IsEqualIID(riid, &IID_IDispatch)   ||
+       IsEqualIID(riid, &IID__ADO)        ||
+       IsEqualIID(riid, &IID_Command15)  ||
+       IsEqualIID(riid, &IID_Command25)  ||
+       IsEqualIID(riid, &IID__Command))
+    {
+        *out = iface;
+    }
+    else
+    {
+        FIXME("interface %s not implemented\n", debugstr_guid(riid));
+        return E_NOINTERFACE;
+    }
+
+    _Command_AddRef(iface);
+    return S_OK;
+}
+
+static ULONG WINAPI command_AddRef(_Command *iface)
+{
+    command *This = impl_from_Command(iface);
+    TRACE("(%p)\n", This);
+
+    return InterlockedIncrement(&This->ref);
+}
+
+static ULONG WINAPI command_Release(_Command *iface)
+{
+    command *This = impl_from_Command(iface);
+    LONG ref;
+
+    TRACE("(%p)\n", This);
+
+    ref = InterlockedDecrement(&This->ref);
+    if(ref == 0)
+        heap_free(This);
+
+    return ref;
+}
+
+static HRESULT WINAPI command_GetTypeInfoCount(_Command *iface, UINT *pctinfo)
+{
+    command *This = impl_from_Command(iface);
+    TRACE("(%p)->()\n", This);
+
+    *pctinfo = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI command_GetTypeInfo(_Command *iface, UINT iTInfo, LCID lcid, ITypeInfo **typeinfo)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%u %u %p)\n", This, iTInfo, lcid, typeinfo);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_GetIDsOfNames(_Command *iface, REFIID riid, LPOLESTR *rgszNames,
+        UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%s %p %u %u %p)\n", This, debugstr_guid(riid), rgszNames, cNames, lcid, rgDispId);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_Invoke(_Command *iface, DISPID dispIdMember, REFIID riid,
+        LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
+        UINT *puArgErr)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%d %s %d %d %p %p %p %p)\n", This, dispIdMember, debugstr_guid(riid),
+           lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_Properties(_Command *iface, Properties **props)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, props);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_ActiveConnection(_Command *iface, _Connection **connection)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, connection);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_putref_ActiveConnection(_Command *iface, _Connection *connection)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, connection);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_put_ActiveConnection(_Command *iface, VARIANT connection)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->()\n", This);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_CommandText(_Command *iface, BSTR *text)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, text);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_put_CommandText(_Command *iface, BSTR text)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(text));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_CommandTimeout(_Command *iface, LONG *timeout)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, timeout);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_put_CommandTimeout(_Command *iface, LONG timeout)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%d)\n", This, timeout);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_Prepared(_Command *iface, VARIANT_BOOL *prepared)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, prepared);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_put_Prepared(_Command *iface, VARIANT_BOOL prepared)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%d)\n", This, prepared);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_Execute(_Command *iface, VARIANT *recordsaffected, VARIANT *parameters,
+    LONG options, _Recordset **recordset)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p %p %d %p)\n", This, recordsaffected, parameters, options, recordset);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_CreateParameter(_Command *iface, BSTR name, DataTypeEnum type, 
+    ParameterDirectionEnum direction, LONG size, VARIANT value, _Parameter **parameter)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%s %d %d %d %p)\n", This, debugstr_w(name), type, direction, size,
+	    parameter);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_Parameters(_Command *iface, Parameters **parameters)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, parameters);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_put_CommandType(_Command *iface, CommandTypeEnum cmdtype)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%d)\n", This, cmdtype);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_CommandType(_Command *iface, CommandTypeEnum *cmdtype)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, cmdtype);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_Name(_Command *iface, BSTR *name)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_put_Name(_Command *iface, BSTR name)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(name));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_State(_Command *iface, LONG *state)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, state);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_Cancel(_Command *iface)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->()\n", This);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_putref_CommandStream(_Command *iface, IUnknown *stream)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, stream);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_CommandStream(_Command *iface, VARIANT *stream)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, stream);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_put_Dialect(_Command *iface, BSTR dialect)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(dialect));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_Dialect(_Command *iface, BSTR *dialect)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, dialect);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_put_NamedParameters(_Command *iface, VARIANT_BOOL namedparameters)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%d)\n", This, namedparameters);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI command_get_NamedParameters(_Command *iface, VARIANT_BOOL *namedparameters)
+{
+    command *This = impl_from_Command(iface);
+    FIXME("(%p)->(%p)\n", This, namedparameters);
+
+    return E_NOTIMPL;
+}
+
+static const struct _CommandVtbl command_vtbl =
+{
+	command_QueryInterface,
+	command_AddRef,
+	command_Release,
+	command_GetTypeInfoCount,
+	command_GetTypeInfo,
+	command_GetIDsOfNames,
+	command_Invoke,
+	command_get_Properties,
+	command_get_ActiveConnection,
+	command_putref_ActiveConnection,
+	command_put_ActiveConnection,
+	command_get_CommandText,
+	command_put_CommandText,
+	command_get_CommandTimeout,
+	command_put_CommandTimeout,
+	command_get_Prepared,
+	command_put_Prepared,
+	command_Execute,
+	command_CreateParameter,
+	command_get_Parameters,
+	command_put_CommandType,
+	command_get_CommandType,
+	command_get_Name,
+	command_put_Name,
+	command_get_State,
+	command_Cancel,
+	command_putref_CommandStream,
+	command_get_CommandStream,
+	command_put_Dialect,
+	command_get_Dialect,
+	command_put_NamedParameters,
+	command_get_NamedParameters
+};
+
+HRESULT Command_create(void **out)
+{
+    command *This;
+
+    TRACE("(%p)\n", out);
+
+    *out = NULL;
+
+    This = heap_alloc(sizeof(*This));
+    if (!This)
+	    return E_OUTOFMEMORY;
+
+    This->_Command_iface.lpVtbl = &command_vtbl;
+    This->ref = 1;
+
+    *out = &This->_Command_iface;
+
+    return S_OK;
+}
\ No newline at end of file
diff --git a/dlls/msado15/msado15.c b/dlls/msado15/msado15.c
index b8adf74..07a642f 100644
--- a/dlls/msado15/msado15.c
+++ b/dlls/msado15/msado15.c
@@ -130,6 +130,7 @@ static const struct IClassFactoryVtbl msadocf_vtbl =
     msadocf_LockServer
 };
 
+static ClassFactory commandcf    = { { &msadocf_vtbl }, Command_create };
 static ClassFactory connectioncf = { { &msadocf_vtbl }, Connecton_create };
 static ClassFactory recordsetncf = { { &msadocf_vtbl }, Recordset_create };
 
@@ -150,6 +151,10 @@ HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
     {
         cf = &recordsetncf.IClassFactory_iface;
     }
+    else if(IsEqualCLSID( rclsid, &CLSID_Command))
+    {
+        cf = &commandcf.IClassFactory_iface;
+    }
 
     if (!cf)
         return CLASS_E_CLASSNOTAVAILABLE;
diff --git a/dlls/msado15/msado15_private.h b/dlls/msado15/msado15_private.h
index 3bbfcbf..dfecc14 100644
--- a/dlls/msado15/msado15_private.h
+++ b/dlls/msado15/msado15_private.h
@@ -26,5 +26,6 @@ static inline BOOL heap_free(void *mem)
     return HeapFree(GetProcessHeap(), 0, mem);
 }
 
+extern HRESULT Command_create(void **out) DECLSPEC_HIDDEN;
 extern HRESULT Connecton_create(void **out) DECLSPEC_HIDDEN;
-extern HRESULT Recordset_create(void **out) DECLSPEC_HIDDEN;
\ No newline at end of file
+extern HRESULT Recordset_create(void **out) DECLSPEC_HIDDEN;
-- 
1.9.1

