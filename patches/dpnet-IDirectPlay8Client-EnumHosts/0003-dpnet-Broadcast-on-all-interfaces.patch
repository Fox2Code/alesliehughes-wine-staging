From 2cba9a75f2e70024252fb32407a8dfd9d06d3dad Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 13 Oct 2015 09:08:37 +1100
Subject: [PATCH 3/5] dpnet: Broadcast on all interfaces

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/dpnet/Makefile.in |  2 +-
 dlls/dpnet/client.c    | 60 ++++++++++++++++++++++++++++++++++++++++++++------
 2 files changed, 54 insertions(+), 8 deletions(-)

diff --git a/dlls/dpnet/Makefile.in b/dlls/dpnet/Makefile.in
index 541e104..73ab6fa 100644
--- a/dlls/dpnet/Makefile.in
+++ b/dlls/dpnet/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = dpnet.dll
 IMPORTLIB = dpnet
-IMPORTS   = dxguid uuid ole32 advapi32 ws2_32
+IMPORTS   = dxguid uuid ole32 advapi32 ws2_32 iphlpapi
 
 C_SRCS = \
 	address.c \
diff --git a/dlls/dpnet/client.c b/dlls/dpnet/client.c
index 50f969e..623343d 100644
--- a/dlls/dpnet/client.c
+++ b/dlls/dpnet/client.c
@@ -22,6 +22,7 @@
 #include "config.h"
 
 #include <stdarg.h>
+#include <stdio.h>
 #include <errno.h>
 
 #define COBJMACROS
@@ -31,6 +32,7 @@
 #include "winuser.h"
 #include "objbase.h"
 #include "winsock2.h"
+#include "iphlpapi.h"
 
 #include "wine/debug.h"
 
@@ -151,6 +153,15 @@ struct EnumHostData
     HANDLE event;
 };
 
+static const char *ntoa( DWORD ip )
+{
+    static char buffer[40];
+
+    ip = htonl(ip);
+    sprintf( buffer, "%u.%u.%u.%u", (ip >> 24) & 0xff, (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff );
+    return buffer;
+}
+
 static DWORD WINAPI EnumNetworkHost(PVOID lpVoid)
 {
     struct EnumHostData *enumdata = (struct EnumHostData*)lpVoid;
@@ -165,6 +176,10 @@ static DWORD WINAPI EnumNetworkHost(PVOID lpVoid)
     int BufLen = 1024;
     struct sockaddr_in from;
     int fromlen = sizeof(from);
+    MIB_IPADDRTABLE *ipTable = NULL;
+    ULONG tablelen = 0;
+    DWORD ipRet;
+    int i;
 
     if (WSAStartup(MAKEWORD(2, 2), &data))
         return 1;
@@ -193,6 +208,24 @@ static DWORD WINAPI EnumNetworkHost(PVOID lpVoid)
        goto cleanup;
     }
 
+    ipRet = GetIpAddrTable(ipTable, &tablelen, FALSE);
+    if (ipRet == ERROR_INSUFFICIENT_BUFFER)
+    {
+        ipTable = (MIB_IPADDRTABLE *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, tablelen);
+        if(!ipTable)
+        {
+            ERR("Failed to bind socket\n");
+            goto cleanup;
+        }
+
+        ipRet = GetIpAddrTable(ipTable, &tablelen, FALSE);
+        if(ipRet != NO_ERROR)
+        {
+            ERR("Failed to bind socket\n");
+            goto cleanup;
+        }
+    }
+
     while(TRUE)
     {
         BufLen = 1024;
@@ -214,13 +247,25 @@ static DWORD WINAPI EnumNetworkHost(PVOID lpVoid)
 
             from.sin_family = AF_INET;
             from.sin_port = htons(DPNA_DPNSVR_PORT);
-            /* TODO - Loop each interface */
-            from.sin_addr.s_addr = inet_addr("255.255.255.255");
-            err = sendto(sock, (void *)&query, sizeof(query), 0,  (struct sockaddr *)&from, sizeof(struct sockaddr_in));
-            if(err == -1)
-                ERR("sendto failed(%d)\n", GetLastError());
-            else
-                TRACE("sent (%d)\n", err);
+
+            for(i=0; i < ipTable->dwNumEntries; i++)
+            {
+                const MIB_IPADDRROW *row = &ipTable->table[i];
+                DWORD ipAddr  = row->dwAddr;
+                DWORD netmask = row->dwMask;
+                DWORD baddr   = ipAddr & netmask;
+                if (row->dwBCastAddr)
+                    baddr |= ~netmask;
+
+                TRACE("Addr: %s\n", ntoa(baddr));
+
+                from.sin_addr.s_addr = baddr;
+                err = sendto(sock, (void *)&query, sizeof(query), 0,  (struct sockaddr *)&from, sizeof(struct sockaddr_in));
+                if(err == -1)
+                    ERR("sendto failed(%d)\n", GetLastError());
+                else
+                    TRACE("sent (%d)\n", err);
+            }
 
             starttime = GetTickCount();
         }
@@ -297,6 +342,7 @@ static DWORD WINAPI EnumNetworkHost(PVOID lpVoid)
 cleanup:
     IDirectPlay8Address_Release(enumdata->host);
     IDirectPlay8Address_Release(enumdata->device);
+    HeapFree(GetProcessHeap(), 0, ipTable);
     HeapFree(GetProcessHeap(), 0, enumdata);
     closesocket(sock);
     WSACleanup();
-- 
1.9.1

