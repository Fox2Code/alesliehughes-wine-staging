From 0b6a05e2592503f204f878c82ceeb805c03a0f69 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 30 Nov 2016 12:12:52 +1100
Subject: [PATCH 16/17] dpnet: to merge Enum_Connect

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/dpnet/client.c        | 418 ++++++++++++++++++++++++++++++---------------
 dlls/dpnet/dpnet_private.h |   2 +
 2 files changed, 278 insertions(+), 142 deletions(-)

diff --git a/dlls/dpnet/client.c b/dlls/dpnet/client.c
index c2a91a4..71d8bca 100644
--- a/dlls/dpnet/client.c
+++ b/dlls/dpnet/client.c
@@ -542,6 +542,257 @@ static DWORD WINAPI enumhost_thread(void *threaddata)
     return 0;
 }
 
+struct connect_data
+{
+    SOCKET sock;
+    GUID   app_guid;
+    DWORD  session;
+    struct sockaddr_in addr;
+    const DPN_APPLICATION_DESC *app_desc;
+    WCHAR *username;
+
+    HANDLE cancelevent;
+    PFNDPNMESSAGEHANDLER msghandler;
+};
+
+static DWORD WINAPI connect_thread(void *threaddata)
+{
+    struct connect_data *tdata = (struct connect_data *)threaddata;
+    HRESULT hr = S_OK;
+    char temp[1024] = {0};
+    DWORD buflen;
+    BOOL connected = FALSE;
+    int n/*, timeout = 0*/;
+    struct sockaddr_in from;
+    int fromlen = sizeof(from);
+    DPNID dpnid = 0;
+    DWORD starttime;
+
+    // Initialize a connection to the server.
+    if(init_packet_connect(tdata->sock, tdata->session, &tdata->addr) == -1)
+    {
+        ERR("init_packet_connect\n");
+        hr = DPNERR_USERCANCEL;
+    }
+
+    while(!connected && hr == S_OK)
+    {
+        buflen = sizeof(temp);
+        n = recvfrom(tdata->sock, temp, buflen, 0, (struct sockaddr *)&from, &fromlen);
+        FIXME("Received %d.\n", n);
+        if(n >= (int)sizeof(struct DFRAME_PACKET))
+        {
+            struct DFRAME_PACKET *packet = (struct DFRAME_PACKET *)temp;
+
+            if(packet->command & PACKET_COMMAND_DATA)
+            {
+                struct DFRAME_PACKET_TYPE *dframe = (struct DFRAME_PACKET_TYPE *)temp;
+                
+                switch(dframe->type)
+                {
+                    case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
+                    {
+                        struct DN_SEND_CONNECT_INFO *info = (struct DN_SEND_CONNECT_INFO *)temp;
+
+                        FIXME("DN_MSG_INTERNAL_SEND_CONNECT_INFO\n");
+                        if(dframe_packet_session_ack(tdata->sock, &tdata->addr, packet->nseq) == -1)
+                        {
+                            ERR("dframe_packet_keepalive\n");
+                            hr = DPNERR_USERCANCEL;
+                        }
+                        dpnid = info->dpnid;
+                        connected = TRUE;
+
+                        break;
+                    }
+                    default:
+                        /* System Messages */
+                        if(packet->command & PACKET_COMMAND_USER_1)
+                        {
+                            FIXME("PACKET_COMMAND_USER_1 not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                        }
+                        else
+                        {
+                            if(packet->control & PACKET_CONTROL_KEEPALIVE_OR_CORRELATE)
+                            {
+                                static int nct = 0;
+                                FIXME("PACKET_CONTROL_KEEPALIVE_OR_CORRELATE\n");
+                                if(nct > 3)
+                                    connected = TRUE;
+                                nct++;
+                            }
+                            else
+                            {
+                                FIXME("data not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                            }
+                        }
+                }
+            }
+            else
+            {
+                if(packet->control == FRAME_EXOPCODE_CONNECTED)
+                {
+                    struct DN_MESSAGE_CONNECT *connected = (struct DN_MESSAGE_CONNECT *)temp;
+
+                    dn_packet_connected(tdata->sock, tdata->session, connected->msgid, &tdata->addr);
+                    if(dframe_packet_keepalive(tdata->sock, tdata->session, &tdata->addr) == -1)
+                    {
+                        ERR("dframe_packet_keepalive\n");
+                        hr = DPNERR_USERCANCEL;
+                    }
+
+                    if(dframe_packet_player_connect_info_ex(tdata->sock, tdata->session, tdata->app_desc, tdata->username, &tdata->addr) == -1)
+                    {
+                        ERR("dframe_packet_player_connect_info_ex\n");
+                            hr = DPNERR_USERCANCEL;
+                    }
+                }
+                else if(packet->control == FRAME_EXOPCODE_HARD_DISCONNECT)
+                {
+                    ERR("FRAME_EXOPCODE_HARD_DISCONNECT\n");
+                    hr = DPNERR_USERCANCEL;
+                }
+                else if(packet->control == FRAME_EXOPCODE_SACK)
+                {
+                    FIXME("received FRAME_EXOPCODE_SACK\n");
+                }
+                else
+                {
+                    FIXME("CFRAME not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                }
+
+            }
+        }
+    }
+
+    {
+        struct SACK_PACKET sack;
+        int err;
+
+        sack.command = 0x80;
+        sack.opcode  = FRAME_EXOPCODE_SACK;
+        sack.flags   = SACK_FLAGS_RESPONSE;
+        sack.retry   = FALSE;
+        sack.nseq    = 3;
+        sack.nrcv    = 4;
+        sack.padding = 0;
+        sack.timestamp = GetTickCount();
+        
+        err = sendto(tdata->sock, (void *)&sack, sizeof(sack), 0, (struct sockaddr *)&tdata->addr, sizeof(struct sockaddr_in));
+        if(err == -1)
+            ERR("Sendto failed (%d).\n", WSAGetLastError());
+        else
+            FIXME("sack sent %d\n", err);
+    }
+
+//    if(!(flags & DPNCONNECT_SYNC))
+    {
+        DPNMSG_CONNECT_COMPLETE complete;
+
+        complete.dwSize = sizeof(complete);
+        complete.hAsyncOp = 0;
+        complete.pvUserContext = NULL; //This->usercontext;
+        complete.hResultCode = hr;
+        complete.pvApplicationReplyData = NULL;
+        complete.dwApplicationReplyDataSize = 0;
+        complete.dpnidLocal = dpnid;
+
+        tdata->msghandler(NULL, DPN_MSGID_CONNECT_COMPLETE, &complete);
+    }
+
+    starttime = GetTickCount();
+    while(TRUE)
+    {
+        buflen = sizeof(temp);
+        n = recvfrom(tdata->sock, temp, buflen, 0, (struct sockaddr *)&from, &fromlen);
+        if(n != -1)
+            FIXME("2. Received %d.\n", n);
+        if(n >= (int)sizeof(struct DFRAME_PACKET))
+        {
+            struct DFRAME_PACKET *packet = (struct DFRAME_PACKET *)temp;
+
+            if(packet->command & PACKET_COMMAND_DATA)
+            {
+                struct DFRAME_PACKET_TYPE *dframe = (struct DFRAME_PACKET_TYPE *)temp;
+                
+                switch(dframe->type)
+                {
+                    default:
+                        /* System Messages */
+                        if(packet->command & PACKET_COMMAND_USER_1)
+                        {
+                            FIXME("PACKET_COMMAND_USER_1 not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                        }
+                        else
+                        {
+                            if(packet->control & PACKET_CONTROL_KEEPALIVE_OR_CORRELATE)
+                            {
+                                struct DFRAME_PACKET_KEEPALIVE *keepalive = (struct DFRAME_PACKET_KEEPALIVE *)packet;
+                                struct SACK_PACKET sack;
+                                int err;
+
+                                FIXME("PACKET_CONTROL_KEEPALIVE_OR_CORRELATE\n");
+
+                                sack.command = 0x80;
+                                sack.opcode  = FRAME_EXOPCODE_SACK;
+                                sack.flags   = SACK_FLAGS_RESPONSE;
+                                sack.retry   = FALSE;
+                                sack.nseq    = keepalive->nseq;
+                                sack.nrcv    = keepalive->seq;
+                                sack.padding = 0;
+                                sack.timestamp = GetTickCount();
+                                
+                                err = sendto(tdata->sock, (void *)&sack, sizeof(sack), 0, (struct sockaddr *)&tdata->addr, sizeof(struct sockaddr_in));
+                                if(err == -1)
+                                    ERR("Sendto failed (%d).\n", WSAGetLastError());
+                                else
+                                    FIXME("sack sent %d\n", err);
+                            }
+                            else
+                            {
+                                FIXME("data not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                            }
+
+                        }
+                }
+            }
+            else
+            {
+                if(packet->control == FRAME_EXOPCODE_HARD_DISCONNECT)
+                {
+                    ERR("FRAME_EXOPCODE_HARD_DISCONNECT\n");
+                    hr = DPNERR_USERCANCEL;
+                }
+                else if(packet->control == FRAME_EXOPCODE_SACK)
+                {
+                    ERR("received FRAME_EXOPCODE_SACK\n");
+                }
+                else
+                {
+                    FIXME("CFRAME not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                }
+
+            }
+
+            if( (starttime - GetTickCount()) >= 10000)
+            {
+                FIXME("Sending Keepalive\n");
+                if(dframe_packet_keepalive(tdata->sock, tdata->session, &tdata->addr) == -1)
+                {
+                    ERR("dframe_packet_keepalive\n");
+                    hr = DPNERR_USERCANCEL;
+                }
+
+                starttime = GetTickCount();
+            }
+        }
+    }
+
+    heap_free(threaddata);
+
+    return 0;
+}
+
 static HRESULT WINAPI IDirectPlay8ClientImpl_EnumHosts(IDirectPlay8Client *iface,
         PDPN_APPLICATION_DESC const pApplicationDesc, IDirectPlay8Address * const pAddrHost,
         IDirectPlay8Address * const pDeviceInfo, void * const pUserEnumData,
@@ -622,7 +873,7 @@ static HRESULT WINAPI IDirectPlay8ClientImpl_EnumHosts(IDirectPlay8Client *iface
     }
 
     if(pAsyncHandle)
-        *pAsyncHandle = PtrToUlong(This->cancelevent);
+        *pAsyncHandle = PtrToUlong(This->enumthread);
 
     return (dwFlags & DPNENUMHOSTS_SYNC) ? DPN_OK : DPNSUCCESS_PENDING;
 }
@@ -661,13 +912,8 @@ static HRESULT WINAPI IDirectPlay8ClientImpl_Connect(IDirectPlay8Client *iface,
     DWORD size, port, type;
     char *buffer;
     struct sockaddr_in addr;
-    char temp[1024] = {0};
-    DWORD buflen;
-    struct sockaddr_in from;
-    int fromlen = sizeof(from);
-    int n/*, timeout = 0*/;
-    BOOL connected = FALSE;
-    DPNID dpnid = 0;
+    struct connect_data *tdata;
+//    DPNID dpnid = 0;
 
     FIXME("(%p) : (%p, %p, %p, %p, %p, %p, %u, %p, %p, %x)\n", This, app_desc, host_addr,
         device, security, credentials, user_data, data_size, context, async_handle, flags);
@@ -679,10 +925,18 @@ static HRESULT WINAPI IDirectPlay8ClientImpl_Connect(IDirectPlay8Client *iface,
     IDirectPlay8Address_AddRef(host_addr);
 
     /* Get rid of the EnumHost Thread. */
-    IDirectPlay8Client_CancelAsyncOperation(iface, PtrToUlong(This->cancelevent), 0);
 
-    if(!(flags & DPNCONNECT_SYNC))
-        FIXME("Connect asynchronously currently not support.\n");
+    /* TODO - Connect doesn't send thought a Cancel Event. Confirm? */
+    SetEvent(This->cancelevent);
+    CloseHandle(This->cancelevent);
+
+    WaitForSingleObject(This->enumthread, INFINITE);
+
+    CloseHandle(This->enumthread);
+    This->enumthread = NULL;
+
+//    if(!(flags & DPNCONNECT_SYNC))
+//        FIXME("Connect asynchronously currently not support.\n");
 
     /* Should we create a new socket - so extra Enumhost packets are mixed up with this one? */
     /* Flush the socket? */
@@ -714,7 +968,7 @@ static HRESULT WINAPI IDirectPlay8ClientImpl_Connect(IDirectPlay8Client *iface,
     hr = IDirectPlay8Address_GetComponentByName(host_addr, DPNA_KEY_HOSTNAME, NULL, &size, &type);
     if(hr != DPNERR_BUFFERTOOSMALL)
     {
-        ERR("Failed to get host name size.\n");
+        ERR("Failed to get host na    me size.\n");
 
         return hr;
     }
@@ -751,144 +1005,24 @@ static HRESULT WINAPI IDirectPlay8ClientImpl_Connect(IDirectPlay8Client *iface,
 
     hr = S_OK;
 
-    // Initialize a connection to the server.
-    if(init_packet_connect(This->sock, This->session, &addr) == -1)
-    {
-        ERR("init_packet_connect\n");
-        hr = DPNERR_USERCANCEL;
-    }
-
-    while(!connected && hr == S_OK)
-    {
-        buflen = sizeof(temp);
-        n = recvfrom(This->sock, temp, buflen, 0, (struct sockaddr *)&from, &fromlen);
-        FIXME("Received %d.\n", n);
-        if(n >= (int)sizeof(struct DFRAME_PACKET))
-        {
-            struct DFRAME_PACKET *packet = (struct DFRAME_PACKET *)temp;
-
-            if(packet->command & PACKET_COMMAND_DATA)
-            {
-                struct DFRAME_PACKET_TYPE *dframe = (struct DFRAME_PACKET_TYPE *)temp;
-                
-                switch(dframe->type)
-                {
-                    case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
-                    {
-                        struct DN_SEND_CONNECT_INFO *info = (struct DN_SEND_CONNECT_INFO *)temp;
-
-                        FIXME("DN_MSG_INTERNAL_SEND_CONNECT_INFO\n");
-                        if(dframe_packet_session_ack(This->sock, &addr, packet->nseq) == -1)
-                        {
-                            ERR("dframe_packet_keepalive\n");
-                            hr = DPNERR_USERCANCEL;
-                        }
-                        dpnid = info->dpnid;
-                        connected = TRUE;
-
-                        break;
-                    }
-                    default:
-                        /* System Messages */
-                        if(packet->command & PACKET_COMMAND_USER_1)
-                        {
-                            FIXME("PACKET_COMMAND_USER_1 not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
-                        }
-                        else
-                        {
-                            if(packet->control & PACKET_CONTROL_KEEPALIVE_OR_CORRELATE)
-                            {
-                                static int nct = 0;
-                                FIXME("PACKET_CONTROL_KEEPALIVE_OR_CORRELATE\n");
-                                if(nct > 3)
-                                    connected = TRUE;
-                                nct++;
-                            }
-                            else
-                            {
-                                FIXME("data not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
-                            }
-                        }
-                }
-            }
-            else
-            {
-                if(packet->control == FRAME_EXOPCODE_CONNECTED)
-                {
-                    struct DN_MESSAGE_CONNECT *connected = (struct DN_MESSAGE_CONNECT *)temp;
-
-                    dn_packet_connected(This->sock, This->session, connected->msgid, &addr);
-                    if(dframe_packet_keepalive(This->sock, This->session, &addr) == -1)
-                    {
-                        ERR("dframe_packet_keepalive\n");
-                        hr = DPNERR_USERCANCEL;
-                    }
+    tdata = heap_alloc(sizeof(struct connect_data));
+    tdata->sock        = This->sock;
+    tdata->msghandler  = This->msghandler;
+    tdata->app_guid    = app_desc->guidApplication;
+    tdata->session     = This->session;
+    tdata->addr        = addr;
+    tdata->app_desc    = app_desc;
+    tdata->username    = This->username;
+    tdata->cancelevent = This->cancelevent = CreateEventA( NULL, TRUE, FALSE, NULL);
 
-                    if(dframe_packet_player_connect_info_ex(This->sock, This->session, app_desc, This->username, &addr) == -1)
-                    {
-                        ERR("dframe_packet_player_connect_info_ex\n");
-                        hr = DPNERR_USERCANCEL;
-                    }
-                }
-                else if(packet->control == FRAME_EXOPCODE_HARD_DISCONNECT)
-                {
-                    ERR("FRAME_EXOPCODE_HARD_DISCONNECT\n");
-                    hr = DPNERR_USERCANCEL;
-                }
-                else if(packet->control == FRAME_EXOPCODE_SACK)
-                {
-                    ERR("received FRAME_EXOPCODE_SACK\n");
-                }
-                else
-                {
-                    FIXME("CFRAME not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
-                }
-
-            }
-        }
-    }
+    This->connectthread = CreateThread(NULL, 0, &connect_thread, tdata, 0, 0);
 
 sendsync:
 
-{
-    struct SACK_PACKET sack;
-    int err;
-
-    sack.command = 0x80;
-    sack.opcode  = FRAME_EXOPCODE_SACK;
-    sack.flags   = SACK_FLAGS_RESPONSE;
-    sack.retry   = FALSE;
-    sack.nseq    = 3;
-    sack.nrcv    = 4;
-    sack.padding = 0;
-    sack.timestamp = GetTickCount();
-    
-    err = sendto(This->sock, (void *)&sack, sizeof(sack), 0, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
-    if(err == -1)
-        ERR("Sendto failed (%d).\n", WSAGetLastError());
-    else
-        FIXME("sack sent %d\n", err);
 
-    return err;
-}
 
     IDirectPlay8Address_Release(host_addr);
 
-    //if(!(flags & DPNCONNECT_SYNC))
-    {
-        DPNMSG_CONNECT_COMPLETE complete;
-
-        complete.dwSize = sizeof(complete);
-        complete.hAsyncOp = 0;
-        complete.pvUserContext = This->usercontext;
-        complete.hResultCode = hr;
-        complete.pvApplicationReplyData = NULL;
-        complete.dwApplicationReplyDataSize = 0;
-        complete.dpnidLocal = dpnid;
-
-        This->msghandler(NULL, DPN_MSGID_CONNECT_COMPLETE, &complete);
-    }
-
     /* Create a thread to send/receive packets. */
 
     return hr;
diff --git a/dlls/dpnet/dpnet_private.h b/dlls/dpnet/dpnet_private.h
index bda253c..bd555f7 100644
--- a/dlls/dpnet/dpnet_private.h
+++ b/dlls/dpnet/dpnet_private.h
@@ -69,6 +69,8 @@ struct IDirectPlay8ClientImpl
     HANDLE enumthread;
     HANDLE cancelevent;
     DWORD session;
+
+    HANDLE connectthread;
 };
 
 /* ------------------- */
-- 
2.10.2

