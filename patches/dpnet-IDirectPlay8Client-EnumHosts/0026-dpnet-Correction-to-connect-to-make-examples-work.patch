From 68376891c753769f8213e69ef4187af9b22375ce Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 14 Dec 2016 11:17:55 +1100
Subject: [PATCH 26/46] dpnet: Correction to connect to make examples work :)

---
 dlls/dpnet/client.c | 148 ++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 110 insertions(+), 38 deletions(-)

diff --git a/dlls/dpnet/client.c b/dlls/dpnet/client.c
index 16bf9bd..f38ec5d 100644
--- a/dlls/dpnet/client.c
+++ b/dlls/dpnet/client.c
@@ -204,6 +204,28 @@ static int dn_packet_connected(SOCKET sock, DWORD session, DWORD msgid, struct s
      return err;
 }
 
+static int dframe_packet_keepalive(SOCKET sock, DWORD session, struct sockaddr_in *addr)
+{
+    struct DFRAME_PACKET_KEEPALIVE packet;
+    int err = -1;
+
+    packet.command =
+        PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_POLL |
+        PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG;
+    packet.control = PACKET_CONTROL_KEEPALIVE_OR_CORRELATE;
+    packet.seq     = 0;
+    packet.nseq    = 0;
+    packet.session = session;
+
+    err = sendto(sock, (void *)&packet, sizeof(packet), 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
+    if(err == -1)
+        ERR("Sendto failed (%d).\n", WSAGetLastError());
+    else
+        FIXME("sent %d\n", err);
+
+    return err;
+}
+
 static int dframe_packet_session_ack(SOCKET sock, struct sockaddr_in *addr, DWORD msgid)
 {
     struct DFRAME_PACKET *packet;
@@ -752,6 +774,7 @@ static HRESULT dplay_connect(SOCKET sock, struct sockaddr_in *serveraddr, DWORD
     DWORD buflen;
     struct sockaddr_in from;
     int fromlen = sizeof(from);
+    int ack = TRUE;
 
     if(init_packet_connect(sock, session, serveraddr) == -1)
     {
@@ -761,6 +784,8 @@ static HRESULT dplay_connect(SOCKET sock, struct sockaddr_in *serveraddr, DWORD
 
     while(!connected && hr == S_OK)
     {
+        ack = TRUE;
+
         if(cancelevent)
         {
             if(WaitForSingleObject(cancelevent, 0) != WAIT_TIMEOUT)
@@ -770,6 +795,7 @@ static HRESULT dplay_connect(SOCKET sock, struct sockaddr_in *serveraddr, DWORD
             }
         }
         buflen = sizeof(temp);
+        memset(temp, 0, sizeof(temp));
         n = recvfrom(sock, temp, buflen, 0, (struct sockaddr *)&from, &fromlen);
         if(n >= (int)sizeof(struct DFRAME_PACKET))
         {
@@ -781,46 +807,75 @@ static HRESULT dplay_connect(SOCKET sock, struct sockaddr_in *serveraddr, DWORD
             {
                 struct DFRAME_PACKET_TYPE *dframe = (struct DFRAME_PACKET_TYPE *)temp;
 
-                if(dframe->type == DN_MSG_INTERNAL_SEND_CONNECT_INFO)
-                {
-                    struct DN_SEND_CONNECT_INFO *info = (struct DN_SEND_CONNECT_INFO *)temp;
+                TRACE("Processing DFRAME_PACKET\n");
 
-                    TRACE("DN_MSG_INTERNAL_SEND_CONNECT_INFO\n");
-                    if(dframe_packet_session_ack(sock, serveraddr, packet->nseq) == -1)
+                switch(dframe->type)
+                {
+                    case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
                     {
-                        ERR("dframe_packet_keepalive\n");
-                        hr = DPNERR_USERCANCEL;
-                    }
-                    /* TODO - Store info->dpnid */
-                    connected = TRUE;
+                        struct DN_SEND_CONNECT_INFO *info = (struct DN_SEND_CONNECT_INFO *)temp;
 
-                    if(cancelevent && msghandler)
-                    {
-                        DPNMSG_CONNECT_COMPLETE complete;
-
-                        complete.dwSize = sizeof(complete);
-                        complete.hAsyncOp = 0;
-                        complete.pvUserContext = NULL; //This->usercontext;
-                        complete.hResultCode = hr;
-                        complete.pvApplicationReplyData = NULL;
-                        complete.dwApplicationReplyDataSize = 0;
-                        complete.dpnidLocal = info->dpnid;
-
-                        hr = msghandler(NULL, DPN_MSGID_CONNECT_COMPLETE, &complete);
-                        if(FAILED(hr))
+                        TRACE("DN_MSG_INTERNAL_SEND_CONNECT_INFO\n");
+                        if(dframe_packet_session_ack(sock, serveraddr, packet->nseq) == -1)
+                        {
+                            ERR("dframe_packet_session_ack\n");
+                            hr = DPNERR_USERCANCEL;
+                        }
+                        /* TODO - Store info->dpnid */
+                        connected = TRUE;
+
+                        if(cancelevent && msghandler)
                         {
-                            ERR("Message Handle for CONNECT_COMPELTE failed (0x%08x).\n", hr);
+                            DPNMSG_CONNECT_COMPLETE complete;
+
+                            complete.dwSize = sizeof(complete);
+                            complete.hAsyncOp = 0;
+                            complete.pvUserContext = NULL; //This->usercontext;
+                            complete.hResultCode = hr;
+                            complete.pvApplicationReplyData = NULL;
+                            complete.dwApplicationReplyDataSize = 0;
+                            complete.dpnidLocal = info->dpnid;
+
+                            hr = msghandler(NULL, DPN_MSGID_CONNECT_COMPLETE, &complete);
+                            if(FAILED(hr))
+                            {
+                                ERR("Message Handle for CONNECT_COMPELTE failed (0x%08x).\n", hr);
+                            }
                         }
+
+                        TRACE("dpnid %08x\n", info->dpnid);
+                        break;
                     }
+                    default:
+                    {
+                        if(packet->control & PACKET_CONTROL_KEEPALIVE_OR_CORRELATE)
+                        {
+                            WARN("Ignoring PACKET_CONTROL_KEEPALIVE_OR_CORRELATE\n");
+                        }
+                        else
+                        {
+                            DPNMSG_RECEIVE received;
 
-                    TRACE("dpnid %08x\n", info->dpnid);
-                }
-                else
-                {
-                    FIXME("Unexpected data. command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                            WARN("Passing on user data\n");
+
+                            received.dwSize             = sizeof(received);
+                            received.dpnidSender        = 0;
+                            received.pvPlayerContext    = NULL;
+                            received.pReceiveData       = &dframe->type;
+                            received.dwReceiveDataSize  = n - sizeof(struct DFRAME_PACKET);
+                            received.hBufferHandle      = 0;
+                            received.dwReceiveFlags     = 0;
+
+                            hr = msghandler(NULL, DPN_MSGID_RECEIVE, &received);
+                            if(hr != S_OK)
+                                ERR("Message Handle for DPN_MSGID_TERMINATE_SESSION failed (0x%08x).\n", hr);
+                        }
+                    }
                 }
             }
-            else
+            else if(n >= (int)sizeof(struct CFRAME_PACKET) &&
+                        ((packet->command == PACKET_COMMAND_CFRAME) ||
+                         (packet->command == (PACKET_COMMAND_CFRAME | PACKET_COMMAND_POLL))))
             {
                 if(packet->control == FRAME_EXOPCODE_CONNECTED)
                 {
@@ -828,6 +883,14 @@ static HRESULT dplay_connect(SOCKET sock, struct sockaddr_in *serveraddr, DWORD
 
                     dn_packet_connected(sock, session, connected->msgid, serveraddr);
 
+                    ack = FALSE;
+
+                    if(dframe_packet_keepalive(sock, session, serveraddr) == -1)
+                    {
+                        ERR("dframe_packet_keepalive\n");
+                        hr = DPNERR_USERCANCEL;
+                    }
+
                     if(dframe_packet_player_connect_info_ex(sock, session, app_desc, username, serveraddr) == -1)
                     {
                         ERR("dframe_packet_player_connect_info_ex\n");
@@ -848,6 +911,11 @@ static HRESULT dplay_connect(SOCKET sock, struct sockaddr_in *serveraddr, DWORD
                     FIXME("CFRAME not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
                 }
             }
+
+            if(FALSE && ack && (packet->command | PACKET_COMMAND_POLL))
+            {
+                dframe_packet_sack_ack(sock, serveraddr, packet->seq, packet->seq);
+            }
         }
     }
 
@@ -865,9 +933,12 @@ static HRESULT dplay_connected(SOCKET sock, struct sockaddr_in *serveraddr, DWOR
     struct sockaddr_in from;
     int fromlen = sizeof(from);
     BOOL connected = TRUE;
+    BOOL ack;
 
     while(hr == DPN_OK && connected)
     {
+        ack = TRUE;
+
         if(cancelevent)
         {
             if(WaitForSingleObject(cancelevent, 0) != WAIT_TIMEOUT)
@@ -902,12 +973,12 @@ static HRESULT dplay_connected(SOCKET sock, struct sockaddr_in *serveraddr, DWOR
                         {
                             if(packet->control & PACKET_CONTROL_KEEPALIVE_OR_CORRELATE)
                             {
-                                struct DFRAME_PACKET_KEEPALIVE *keepalive = (struct DFRAME_PACKET_KEEPALIVE *)packet;
+/*                                struct DFRAME_PACKET_KEEPALIVE *keepalive = (struct DFRAME_PACKET_KEEPALIVE *)packet;
                                 struct SACK_PACKET sack;
                                 int err;
-
+*/
                                 FIXME("PACKET_CONTROL_KEEPALIVE_OR_CORRELATE\n");
-
+/*
                                 sack.command = 0x80;
                                 sack.opcode  = FRAME_EXOPCODE_SACK;
                                 sack.flags   = SACK_FLAGS_RESPONSE;
@@ -922,6 +993,7 @@ static HRESULT dplay_connected(SOCKET sock, struct sockaddr_in *serveraddr, DWOR
                                     ERR("Sendto failed (%d).\n", WSAGetLastError());
                                 else
                                     FIXME("sack sent %d\n", err);
+*/
                             }
                             else if(packet->control == PACKET_CONTROL_END_STREAM)
                             {
@@ -948,7 +1020,7 @@ static HRESULT dplay_connected(SOCKET sock, struct sockaddr_in *serveraddr, DWOR
                             {
                                 DPNMSG_RECEIVE received;
 
-                                TRACE("Passign on user data\n");
+                                TRACE("Passing on user data\n");
 
                                 received.dwSize             = sizeof(received);
                                 received.dpnidSender        = 0;
@@ -960,7 +1032,7 @@ static HRESULT dplay_connected(SOCKET sock, struct sockaddr_in *serveraddr, DWOR
 
                                 hr = msghandler(NULL, DPN_MSGID_RECEIVE, &received);
                                 if(hr != S_OK)
-                                    ERR("Message Handle for DPN_MSGID_TERMINATE_SESSION failed (0x%08x).\n", hr);
+                                    ERR("Message Handle for DPNMSG_RECEIVE failed (0x%08x).\n", hr);
                             }
 
                         }
@@ -991,9 +1063,9 @@ static HRESULT dplay_connected(SOCKET sock, struct sockaddr_in *serveraddr, DWOR
                 FIXME("Packet not support.... size(%d), command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", n, packet->command, packet->control, packet->seq, packet->nseq);
             }
 
-            if(connected && (packet->command | PACKET_COMMAND_POLL))
+            if(ack && (packet->command | PACKET_COMMAND_POLL))
             {
-                dframe_packet_sack_ack(sock, serveraddr, packet->seq, packet->seq);
+                dframe_packet_sack_ack(sock, serveraddr, packet->seq, packet->seq+1);
             }
         }
     }
-- 
1.9.1

