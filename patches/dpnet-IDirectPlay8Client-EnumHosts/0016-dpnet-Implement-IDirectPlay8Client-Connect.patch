From 79c1de33e6377645c7b3739a0c3291accaf0942a Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 5 Dec 2016 12:09:33 +1100
Subject: [PATCH 16/20] dpnet: Implement IDirectPlay8Client Connect

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/dpnet/client.c        | 540 ++++++++++++++++++++++++++++++++++++++++++++-
 dlls/dpnet/dpnet_private.h |   4 +
 dlls/dpnet/dppacket.h      | 162 ++++++++++++++
 3 files changed, 696 insertions(+), 10 deletions(-)

diff --git a/dlls/dpnet/client.c b/dlls/dpnet/client.c
index b367c35..d5e2b6e 100644
--- a/dlls/dpnet/client.c
+++ b/dlls/dpnet/client.c
@@ -29,6 +29,7 @@
 #include "wingdi.h"
 #include "winuser.h"
 #include "objbase.h"
+#include "ntsecapi.h"
 #include "wine/debug.h"
 
 #include "dpnet_private.h"
@@ -101,6 +102,61 @@ static SOCKET find_free_socket(void)
     return sock;
 }
 
+static BOOL dpaddress_to_sockaddr(IDirectPlay8Address *host_addr, struct sockaddr_in *addr)
+{
+    DWORD size, type, port;
+    char *buffer;
+    HRESULT hr;
+
+    size = sizeof(port);
+    hr = IDirectPlay8Address_GetComponentByName(host_addr, DPNA_KEY_PORT, &port, &size, &type);
+    if(FAILED(hr))
+    {
+        ERR("Failed to get host port.\n");
+        return FALSE;
+    }
+
+    size = 0;
+    type = 0;
+    hr = IDirectPlay8Address_GetComponentByName(host_addr, DPNA_KEY_HOSTNAME, NULL, &size, &type);
+    if(hr != DPNERR_BUFFERTOOSMALL)
+    {
+        ERR("Failed to get host name size.\n");
+        return FALSE;
+    }
+
+    if(type != DPNA_DATATYPE_STRING_ANSI)
+         FIXME("Non-Ansi currently not supported\n");
+
+    buffer =  heap_alloc(size);
+    if(!buffer)
+    {
+        ERR("Cannot allocate memory.\n");
+        return FALSE;
+    }
+
+    hr = IDirectPlay8Address_GetComponentByName(host_addr, DPNA_KEY_HOSTNAME, buffer, &size, &type);
+    if(FAILED(hr))
+    {
+        ERR("Failed to get host name.\n");
+
+        heap_free(buffer);
+        return FALSE;
+    }
+    TRACE("Connecting to %s:%d\n", debugstr_a(buffer), port);
+
+    memset(addr, 0, sizeof(*addr));
+
+    addr->sin_family = AF_INET;
+    addr->sin_port = htons(port);
+
+    /* TODO - use getaddrinfo to better handle errors and name lookups. */
+    addr->sin_addr.s_addr = inet_addr(buffer);
+    heap_free(buffer);
+
+    return TRUE;
+}
+
 static void send_async_complete_msg(IDirectPlay8ClientImpl *This, HRESULT hr, DPNHANDLE handle)
 {
     DPNMSG_ASYNC_OP_COMPLETE complete;
@@ -231,7 +287,72 @@ static IDirectPlay8Address *create_sender_address(struct sockaddr_in *addr)
     return sender;
 }
 
-static int send_packet_enum_query(SOCKET sock, GUID application, struct sockaddr_in *from)
+static int init_packet_connect(SOCKET sock, DWORD session, struct sockaddr_in *addr)
+{
+    struct DN_MESSAGE_CONNECT packet;
+    int err;
+
+    packet.command = PACKET_COMMAND_CFRAME | PACKET_COMMAND_POLL;
+    packet.opcode  = FRAME_EXOPCODE_CONNECT;
+    packet.msgid   = 0;
+    packet.rspid   = 0;
+    packet.protocol = PROTOCOL_VERSION;
+    packet.session  = session;
+    packet.timestamp = GetTickCount();
+
+    err = sendto(sock, (void *)&packet, sizeof(packet), 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
+    if(err == -1)
+        ERR("Sendto failed (%d).\n", WSAGetLastError());
+    else
+        FIXME("sent %d\n", err);
+
+    return err;
+}
+
+/* 2.2.1.2 DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO_EX */
+static int dframe_packet_player_connect_info_ex(SOCKET sock, DWORD session, const DPN_APPLICATION_DESC * const app_desc,
+                            WCHAR *name, struct sockaddr_in *addr)
+{
+    struct DFRAME_PACKET *packet;
+    struct DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO_EX *info;
+    int err;
+    int size;
+
+    size = sizeof(struct DFRAME_PACKET) + sizeof(*info) + ((lstrlenW(name)+1) * sizeof(WCHAR));
+    packet = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+
+    if(!packet)
+        return -1;
+
+    packet->command =
+        PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_POLL |
+        PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG | PACKET_COMMAND_USER_1;
+    packet->control  = 0;
+    packet->seq      = 1;
+    packet->nseq     = 0;
+
+    info = (struct DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO_EX *)(((char*)packet) + sizeof(struct DFRAME_PACKET));
+    info->type    = DN_MSG_INTERNAL_PLAYER_CONNECT_INFO;
+    info->flags   = DP_OBECT_TYPE_CLIENT;
+    info->version = DP_OBECT_NET_VER_9_0;
+    info->name_offset = sizeof(struct DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO_EX) - sizeof(DWORD);
+    info->name_size = (lstrlenW(name) + 1) * sizeof(WCHAR);
+    info->instance    = app_desc->guidInstance;
+    info->application = app_desc->guidApplication;
+
+    lstrcpyW( (WCHAR*)(((char*)info)+sizeof(*info)), name);
+
+    err = sendto(sock, (void *)packet, size, 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
+    if(err == -1)
+        ERR("Sendto failed (%d).\n", WSAGetLastError());
+    else
+        FIXME("sent %d\n", err);
+
+    heap_free(packet);
+    return err;
+}
+
+static int send_packet_enum_query(SOCKET sock, GUID application, struct sockaddr_in *addr)
 {
     struct ENUM_QUERY query;
     static DWORD payloadvalue = 0;
@@ -243,13 +364,92 @@ static int send_packet_enum_query(SOCKET sock, GUID application, struct sockaddr
     query.application = application;
     query.payload     = payloadvalue++;
 
-    err = sendto(sock, (void *)&query, sizeof(query), 0, (struct sockaddr *)from, sizeof(struct sockaddr_in));
+    err = sendto(sock, (void *)&query, sizeof(query), 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
+    if(err == -1)
+        ERR("Sendto failed (%d).\n", WSAGetLastError());
+    else
+        FIXME("sent %d\n", err);
+
+    return err;
+}
+
+static int dn_packet_connected(SOCKET sock, DWORD session, DWORD msgid, struct sockaddr_in *addr)
+{
+    struct DN_MESSAGE_CONNECT packet;
+    int err;
+
+    packet.command = PACKET_COMMAND_CFRAME;
+    packet.opcode  = FRAME_EXOPCODE_CONNECTED;
+    packet.msgid   = msgid + 1;
+    packet.rspid   = 0;
+    packet.protocol = PROTOCOL_VERSION;
+    packet.session  = session;
+    packet.timestamp = GetTickCount();
+
+    err = sendto(sock, (void *)&packet, sizeof(packet), 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
     if(err == -1)
         ERR("Sendto failed (%d).\n", WSAGetLastError());
+    else
+        FIXME("sent %d\n", err);
 
     return err;
 }
 
+static int dframe_packet_keepalive(SOCKET sock, DWORD session, struct sockaddr_in *addr)
+{
+    struct DFRAME_PACKET_KEEPALIVE packet;
+    int err = -1;
+
+    packet.command =
+        PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_POLL |
+        PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG;
+    packet.control = PACKET_CONTROL_KEEPALIVE_OR_CORRELATE;
+    packet.seq     = 0;
+    packet.nseq    = 0;
+    packet.session = session;
+
+    err = sendto(sock, (void *)&packet, sizeof(packet), 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
+    if(err == -1)
+        ERR("Sendto failed (%d).\n", WSAGetLastError());
+    else
+        FIXME("sent %d\n", err);
+
+    return err;
+}
+
+static int dframe_packet_session_ack(SOCKET sock, struct sockaddr_in *addr, DWORD msgid)
+{
+    struct DFRAME_PACKET *packet;
+    struct DN_ACK_CONNECT_INFO *info;
+    int err;
+    int size;
+
+    size = sizeof(struct DFRAME_PACKET) + sizeof(*info);
+    packet = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+
+    if(!packet)
+        return -1;
+
+    packet->command =
+        PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_POLL |
+        PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG | PACKET_COMMAND_USER_1;
+    packet->control  = 0;
+    packet->seq      = msgid;
+    packet->nseq     = msgid;
+
+    info = (struct DN_ACK_CONNECT_INFO *)(((char*)packet) + sizeof(struct DFRAME_PACKET));
+    info->type    = DN_MSG_INTERNAL_ACK_CONNECT_INFO;
+
+    err = sendto(sock, (void *)packet, size, 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
+    if(err == -1)
+        ERR("Sendto failed (%d).\n", WSAGetLastError());
+    else
+        FIXME("sent %d\n", err);
+
+    heap_free(packet);
+    return err;
+}
+
 static void process_enumhost(SOCKET sock, IDirectPlay8Address *device, PFNDPNMESSAGEHANDLER msghandler, GUID application,
         DWORD retrycnt, DWORD retrytime, DWORD timeout, HANDLE cancelevent)
 {
@@ -407,6 +607,265 @@ static DWORD WINAPI enumhost_thread(void *threaddata)
     return 0;
 }
 
+struct connect_data
+{
+    SOCKET sock;
+    GUID   app_guid;
+    DWORD  session;
+    struct sockaddr_in addr;
+    const DPN_APPLICATION_DESC *app_desc;
+    WCHAR *username;
+
+    HANDLE cancelevent;
+    PFNDPNMESSAGEHANDLER msghandler;
+};
+
+static DWORD WINAPI connect_thread(void *threaddata)
+{
+    struct connect_data *tdata = (struct connect_data *)threaddata;
+    HRESULT hr = S_OK;
+    char temp[1024] = {0};
+    DWORD buflen;
+    BOOL connected = FALSE;
+    int n/*, timeout = 0*/;
+    struct sockaddr_in from;
+    int fromlen = sizeof(from);
+    DPNID dpnid = 0;
+    DWORD starttime;
+
+    // Initialize a connection to the server.
+    if(init_packet_connect(tdata->sock, tdata->session, &tdata->addr) == -1)
+    {
+        ERR("init_packet_connect\n");
+        hr = DPNERR_USERCANCEL;
+    }
+
+    while(!connected && hr == S_OK)
+    {
+        buflen = sizeof(temp);
+        n = recvfrom(tdata->sock, temp, buflen, 0, (struct sockaddr *)&from, &fromlen);
+        FIXME("Received %d.\n", n);
+        if(n >= (int)sizeof(struct DFRAME_PACKET))
+        {
+            struct DFRAME_PACKET *packet = (struct DFRAME_PACKET *)temp;
+
+            if(packet->command & PACKET_COMMAND_DATA)
+            {
+                struct DFRAME_PACKET_TYPE *dframe = (struct DFRAME_PACKET_TYPE *)temp;
+
+                switch(dframe->type)
+                {
+                    case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
+                    {
+                        struct DN_SEND_CONNECT_INFO *info = (struct DN_SEND_CONNECT_INFO *)temp;
+
+                        FIXME("DN_MSG_INTERNAL_SEND_CONNECT_INFO\n");
+                        if(dframe_packet_session_ack(tdata->sock, &tdata->addr, packet->nseq) == -1)
+                        {
+                            ERR("dframe_packet_keepalive\n");
+                            hr = DPNERR_USERCANCEL;
+                        }
+                        dpnid = info->dpnid;
+                        connected = TRUE;
+
+                        break;
+                    }
+                    default:
+                        /* System Messages */
+                        if(packet->command & PACKET_COMMAND_USER_1)
+                        {
+                            FIXME("PACKET_COMMAND_USER_1 not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                        }
+                        else
+                        {
+                            if(packet->control & PACKET_CONTROL_KEEPALIVE_OR_CORRELATE)
+                            {
+                                static int nct = 0;
+                                FIXME("PACKET_CONTROL_KEEPALIVE_OR_CORRELATE\n");
+                                if(nct > 3)
+                                    connected = TRUE;
+                                nct++;
+                            }
+                            else
+                            {
+                                FIXME("data not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                            }
+                        }
+                }
+            }
+            else
+            {
+                if(packet->control == FRAME_EXOPCODE_CONNECTED)
+                {
+                    struct DN_MESSAGE_CONNECT *connected = (struct DN_MESSAGE_CONNECT *)temp;
+
+                    dn_packet_connected(tdata->sock, tdata->session, connected->msgid, &tdata->addr);
+                    if(dframe_packet_keepalive(tdata->sock, tdata->session, &tdata->addr) == -1)
+                    {
+                        ERR("dframe_packet_keepalive\n");
+                        hr = DPNERR_USERCANCEL;
+                    }
+
+                    if(dframe_packet_player_connect_info_ex(tdata->sock, tdata->session, tdata->app_desc, tdata->username, &tdata->addr) == -1)
+                    {
+                        ERR("dframe_packet_player_connect_info_ex\n");
+                            hr = DPNERR_USERCANCEL;
+                    }
+                }
+                else if(packet->control == FRAME_EXOPCODE_HARD_DISCONNECT)
+                {
+                    ERR("FRAME_EXOPCODE_HARD_DISCONNECT\n");
+                    hr = DPNERR_USERCANCEL;
+                }
+                else if(packet->control == FRAME_EXOPCODE_SACK)
+                {
+                    FIXME("received FRAME_EXOPCODE_SACK\n");
+                }
+                else
+                {
+                    FIXME("CFRAME not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                }
+
+            }
+        }
+    }
+
+    {
+        struct SACK_PACKET sack;
+        int err;
+
+        sack.command = 0x80;
+        sack.opcode  = FRAME_EXOPCODE_SACK;
+        sack.flags   = SACK_FLAGS_RESPONSE;
+        sack.retry   = FALSE;
+        sack.nseq    = 3;
+        sack.nrcv    = 4;
+        sack.padding = 0;
+        sack.timestamp = GetTickCount();
+
+        err = sendto(tdata->sock, (void *)&sack, sizeof(sack), 0, (struct sockaddr *)&tdata->addr, sizeof(struct sockaddr_in));
+        if(err == -1)
+            ERR("Sendto failed (%d).\n", WSAGetLastError());
+        else
+            FIXME("sack sent %d\n", err);
+    }
+
+//    if(!(flags & DPNCONNECT_SYNC))
+    {
+        DPNMSG_CONNECT_COMPLETE complete;
+
+        complete.dwSize = sizeof(complete);
+        complete.hAsyncOp = 0;
+        complete.pvUserContext = NULL; //This->usercontext;
+        complete.hResultCode = hr;
+        complete.pvApplicationReplyData = NULL;
+        complete.dwApplicationReplyDataSize = 0;
+        complete.dpnidLocal = dpnid;
+
+        tdata->msghandler(NULL, DPN_MSGID_CONNECT_COMPLETE, &complete);
+    }
+
+    starttime = GetTickCount();
+    while(TRUE)
+    {
+        buflen = sizeof(temp);
+        n = recvfrom(tdata->sock, temp, buflen, 0, (struct sockaddr *)&from, &fromlen);
+        if(n >= (int)sizeof(struct DFRAME_PACKET))
+        {
+            struct DFRAME_PACKET *packet = (struct DFRAME_PACKET *)temp;
+
+            /* Is it a DFRAME packet */
+            if(packet->command & PACKET_COMMAND_DATA)
+            {
+                struct DFRAME_PACKET_TYPE *dframe = (struct DFRAME_PACKET_TYPE *)temp;
+
+                FIXME("Processing DFRAME_PACKET(%d)\n", n);
+
+                switch(dframe->type)
+                {
+                    default:
+                        /* System Messages */
+                        if(packet->command & PACKET_COMMAND_USER_1)
+                        {
+                            FIXME("PACKET_COMMAND_USER_1 not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                        }
+                        else
+                        {
+                            if(packet->control & PACKET_CONTROL_KEEPALIVE_OR_CORRELATE)
+                            {
+                                struct DFRAME_PACKET_KEEPALIVE *keepalive = (struct DFRAME_PACKET_KEEPALIVE *)packet;
+                                struct SACK_PACKET sack;
+                                int err;
+
+                                FIXME("PACKET_CONTROL_KEEPALIVE_OR_CORRELATE\n");
+
+                                sack.command = 0x80;
+                                sack.opcode  = FRAME_EXOPCODE_SACK;
+                                sack.flags   = SACK_FLAGS_RESPONSE;
+                                sack.retry   = FALSE;
+                                sack.nseq    = keepalive->nseq;
+                                sack.nrcv    = keepalive->seq;
+                                sack.padding = 0;
+                                sack.timestamp = GetTickCount();
+
+                                err = sendto(tdata->sock, (void *)&sack, sizeof(sack), 0, (struct sockaddr *)&tdata->addr, sizeof(struct sockaddr_in));
+                                if(err == -1)
+                                    ERR("Sendto failed (%d).\n", WSAGetLastError());
+                                else
+                                    FIXME("sack sent %d\n", err);
+                            }
+                            else
+                            {
+                                FIXME("data not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                            }
+
+                        }
+                }
+            }
+            else if(n >= (int)sizeof(struct CFRAME_PACKET) &&
+                    ((packet->control & PACKET_COMMAND_CFRAME) ||
+                     (packet->control & (PACKET_COMMAND_CFRAME | PACKET_COMMAND_POLL))))
+            {
+                FIXME("Processing CFRAME_PACKET(%d)\n", n);
+
+                if(packet->control == FRAME_EXOPCODE_HARD_DISCONNECT)
+                {
+                    ERR("FRAME_EXOPCODE_HARD_DISCONNECT\n");
+                    hr = DPNERR_USERCANCEL;
+                }
+                else if(packet->control == FRAME_EXOPCODE_SACK)
+                {
+                    ERR("received FRAME_EXOPCODE_SACK\n");
+                }
+                else
+                {
+                    FIXME("CFRAME not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+                }
+            }
+            else
+            {
+                FIXME("Packet not support.... command 0x%02x, control 0x%04x, seq 0x%08x, nseq 0x%04x\n", packet->command, packet->control, packet->seq, packet->nseq);
+            }
+
+            if( (starttime - GetTickCount()) >= 10000)
+            {
+                FIXME("Sending Keepalive\n");
+                if(dframe_packet_keepalive(tdata->sock, tdata->session, &tdata->addr) == -1)
+                {
+                    ERR("dframe_packet_keepalive\n");
+                    hr = DPNERR_USERCANCEL;
+                }
+
+                starttime = GetTickCount();
+            }
+        }
+    }
+
+    heap_free(threaddata);
+
+    return 0;
+}
+
 static HRESULT WINAPI IDirectPlay8ClientImpl_EnumHosts(IDirectPlay8Client *iface,
         PDPN_APPLICATION_DESC const pApplicationDesc, IDirectPlay8Address * const pAddrHost,
         IDirectPlay8Address * const pDeviceInfo, void * const pUserEnumData,
@@ -515,15 +974,71 @@ static HRESULT WINAPI IDirectPlay8ClientImpl_CancelAsyncOperation(IDirectPlay8Cl
 }
 
 static HRESULT WINAPI IDirectPlay8ClientImpl_Connect(IDirectPlay8Client *iface,
-        const DPN_APPLICATION_DESC * const pdnAppDesc, IDirectPlay8Address * const pHostAddr,
-        IDirectPlay8Address * const pDeviceInfo, const DPN_SECURITY_DESC * const pdnSecurity,
-        const DPN_SECURITY_CREDENTIALS * const pdnCredentials, const void * const pvUserConnectData,
-        const DWORD dwUserConnectDataSize, void * const pvAsyncContext,
-        DPNHANDLE * const phAsyncHandle, const DWORD dwFlags)
+        const DPN_APPLICATION_DESC * const app_desc, IDirectPlay8Address * const host_addr,
+        IDirectPlay8Address * const device, const DPN_SECURITY_DESC * const security,
+        const DPN_SECURITY_CREDENTIALS * const credentials, const void * const user_data,
+        const DWORD data_size, void * const context,
+        DPNHANDLE * const async_handle, const DWORD flags)
 {
-  IDirectPlay8ClientImpl *This = impl_from_IDirectPlay8Client(iface);
-  FIXME("(%p):(%p,%p,%x): Stub\n", This, pvAsyncContext, phAsyncHandle, dwFlags);
-  return DPN_OK; 
+    IDirectPlay8ClientImpl *This = impl_from_IDirectPlay8Client(iface);
+    HRESULT hr = DPN_OK;
+    struct connect_data *tdata;
+
+    FIXME("(%p) : (%p, %p, %p, %p, %p, %p, %u, %p, %p, %x)\n", This, app_desc, host_addr,
+        device, security, credentials, user_data, data_size, context, async_handle, flags);
+
+    if(!This->msghandler)
+        return DPNERR_UNINITIALIZED;
+
+    /* CancelAsyncOperation can Relase the host_addr, so keep a reference */
+    IDirectPlay8Address_AddRef(host_addr);
+
+    /* Get rid of the EnumHost Thread. */
+
+    /* TODO - Connect doesn't send thought a Cancel Event. Confirm? */
+    SetEvent(This->cancelevent);
+    CloseHandle(This->cancelevent);
+
+    WaitForSingleObject(This->enumthread, INFINITE);
+
+    CloseHandle(This->enumthread);
+    This->enumthread = NULL;
+
+    if(This->sock == INVALID_SOCKET)
+    {
+        This->sock = find_free_socket();
+        if(This->sock == INVALID_SOCKET)
+        {
+            hr = DPNERR_USERCANCEL;
+            goto cleanup;
+        }
+    }
+
+    if(!dpaddress_to_sockaddr(host_addr, &This->serveraddr))
+    {
+        hr = DPNERR_USERCANCEL;
+        goto cleanup;
+    }
+
+    hr = S_OK;
+
+    tdata = heap_alloc(sizeof(struct connect_data));
+    tdata->sock        = This->sock;
+    tdata->msghandler  = This->msghandler;
+    tdata->app_guid    = app_desc->guidApplication;
+    tdata->session     = This->session;
+    tdata->addr        = This->serveraddr;
+    tdata->app_desc    = app_desc;
+    tdata->username    = This->username;
+    tdata->cancelevent = This->cancelevent = CreateEventA( NULL, TRUE, FALSE, NULL);
+
+    This->connectthread = CreateThread(NULL, 0, &connect_thread, tdata, 0, 0);
+
+cleanup:
+
+    IDirectPlay8Address_Release(host_addr);
+
+    return hr;
 }
 
 static HRESULT WINAPI IDirectPlay8ClientImpl_Send(IDirectPlay8Client *iface,
@@ -735,6 +1250,7 @@ HRESULT DPNET_CreateDirectPlay8Client(IClassFactory *iface, IUnknown *pUnkOuter,
 {
     IDirectPlay8ClientImpl* client;
     HRESULT hr;
+    DWORD random;
 
     TRACE("(%p, %s, %p)\n", pUnkOuter, debugstr_guid(riid), ppv);
 
@@ -743,6 +1259,9 @@ HRESULT DPNET_CreateDirectPlay8Client(IClassFactory *iface, IUnknown *pUnkOuter,
     if(pUnkOuter)
         return CLASS_E_NOAGGREGATION;
 
+    if(!RtlGenRandom(&random, sizeof(random)))
+        return E_FAIL;
+
     client = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IDirectPlay8ClientImpl));
     if (!client)
         return E_OUTOFMEMORY;
@@ -750,6 +1269,7 @@ HRESULT DPNET_CreateDirectPlay8Client(IClassFactory *iface, IUnknown *pUnkOuter,
     client->IDirectPlay8Client_iface.lpVtbl = &DirectPlay8Client_Vtbl;
     client->ref = 1;
     client->sock = INVALID_SOCKET;
+    client->session = random;
 
     init_dpn_sp_caps(&client->spcaps);
 
diff --git a/dlls/dpnet/dpnet_private.h b/dlls/dpnet/dpnet_private.h
index ff4aaae..05f89f6 100644
--- a/dlls/dpnet/dpnet_private.h
+++ b/dlls/dpnet/dpnet_private.h
@@ -68,6 +68,10 @@ struct IDirectPlay8ClientImpl
     SOCKET sock;
     HANDLE enumthread;
     HANDLE cancelevent;
+    DWORD session;
+    struct sockaddr_in serveraddr;
+
+    HANDLE connectthread;
 };
 
 /* ------------------- */
diff --git a/dlls/dpnet/dppacket.h b/dlls/dpnet/dppacket.h
index f3ca955..8c97b03 100644
--- a/dlls/dpnet/dppacket.h
+++ b/dlls/dpnet/dppacket.h
@@ -69,12 +69,174 @@ struct DFRAME_PACKET
     BYTE nseq;
 };
 
+struct DFRAME_PACKET_TYPE
+{
+    BYTE command;
+    BYTE control;
+    BYTE seq;
+    BYTE nseq;
+    BYTE type;
+};
+
+struct DN_MESSAGE_CONNECT
+{
+    BYTE command;
+    BYTE opcode;
+    BYTE msgid;
+    BYTE rspid;
+    DWORD protocol;
+    DWORD session;
+    DWORD timestamp;
+};
+
+struct DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO_EX
+{
+    DWORD type;
+    DWORD flags;
+    DWORD version;
+    DWORD name_offset;
+    DWORD name_size;
+    DWORD data_offset;
+    DWORD data_size;
+    DWORD pwd_offset;
+    DWORD pwd_size;
+    DWORD connect_offset;
+    DWORD connect_size;
+    DWORD url_offset;
+    DWORD url_size;
+    GUID  instance;
+    GUID  application;
+    DWORD alt_address_offset;
+    DWORD alt_address_size;
+};
+
+struct DN_SEND_CONNECT_INFO
+{
+    DWORD type;                   /* DN_MSG_INTERNAL_SEND_CONNECT_INFO */
+    DWORD reply_offset;
+    DWORD reply_size;
+    DWORD size;
+    DWORD flags;
+    DWORD max_players;
+    DWORD cur_players;
+    DWORD session_offset;
+    DWORD session_size;
+    DWORD pwd_offset;
+    DWORD pwd_size;
+    DWORD reserved_offset;
+    DWORD reserved_size;
+    DWORD appdata_offset;
+    DWORD appdata_size;
+    GUID  instance;
+    GUID  application;
+    DWORD dpnid;
+    DWORD version;
+    DWORD ver_not_used;
+    DWORD entry_count;
+    DWORD membership_count;
+};
+
+struct DN_ACK_CONNECT_INFO
+{
+    DWORD type;                   /* DN_MSG_INTERNAL_ACK_CONNECT_INFO */
+};
+
+struct DFRAME_PACKET_KEEPALIVE
+{
+    BYTE command;
+    BYTE control;
+    BYTE seq;
+    BYTE nseq;
+    DWORD session;
+};
+
+struct SACK_PACKET
+{
+    BYTE command;
+    BYTE opcode;
+    BYTE flags;
+    BYTE retry;
+    BYTE nseq;
+    BYTE nrcv;
+    WORD padding;
+    DWORD timestamp;
+};
+
+struct CFRAME_PACKET
+{
+    BYTE command;
+    BYTE opcode;
+    BYTE flags;
+    BYTE retry;
+    BYTE nseq;
+    BYTE nrcv;
+    WORD padding;
+    DWORD timestamp;
+};
+
 #define PACKET_ENUM_QUERY                     0x02
 #define PACKET_ENUM_RESPONSE                  0x03
 
 #define PACKET_QUERY_GUID                     0x01
 #define PACKET_QUERY_NO_GUID                  0x02
 
+#define PROTOCOL_VERSION                      0x00010006
+
+#define PACKET_COMMAND_DATA                   0x01
+#define PACKET_COMMAND_RELIABLE               0x02
+#define PACKET_COMMAND_SEQUENTIAL             0x04
+#define PACKET_COMMAND_POLL                   0x08
+#define PACKET_COMMAND_NEW_MSG                0x10
+#define PACKET_COMMAND_END_MSG                0x20
+#define PACKET_COMMAND_USER_1                 0x40
+#define PACKET_COMMAND_USER_2                 0x80
+#define PACKET_COMMAND_CFRAME                 PACKET_COMMAND_USER_2
+
+#define FRAME_EXOPCODE_CONNECT                0x01
+#define FRAME_EXOPCODE_CONNECTED              0x02
+#define FRAME_EXOPCODE_CONNECTED_SIGNED       0x03
+#define FRAME_EXOPCODE_HARD_DISCONNECT        0x04
+#define FRAME_EXOPCODE_SACK                   0x06
+
+#define PACKET_CONTROL_RETRY                  0x01
+#define PACKET_CONTROL_KEEPALIVE_OR_CORRELATE 0x02
+#define PACKET_CONTROL_COALESCE               0x04
+#define PACKET_CONTROL_END_STREAM             0x08
+#define PACKET_CONTROL_SACK1                  0x10
+#define PACKET_CONTROL_SACK2                  0x20
+#define PACKET_CONTROL_SEND1                  0x40
+#define PACKET_CONTROL_SEND2                  0x80
+
+#define DN_MSG_INTERNAL_PLAYER_CONNECT_INFO 0x000000c1
+#define DN_MSG_INTERNAL_SEND_CONNECT_INFO   0x000000c2
+#define DN_MSG_INTERNAL_ACK_CONNECT_INFO    0x000000c3
+
+#define DP_OBECT_TYPE_CLIENT      0x00000002
+#define DP_OBECT_TYPE_PEER        0x00000004
+
+#define DP_OBECT_NET_VER_8_0      0x00000001
+#define DP_OBECT_NET_VER_8_1      0x00000002
+#define DP_OBECT_NET_VER_POCKETPC 0x00000003
+#define DP_OBECT_NET_VER_W2K3     0x00000005
+#define DP_OBECT_NET_VER_8_2      0x00000006
+#define DP_OBECT_NET_VER_9_0      0x00000007
+#define DP_OBECT_NET_VER_9_0A     0x00000008
+
+#define PACKET_CONTROL_RETRY                  0x01
+#define PACKET_CONTROL_KEEPALIVE_OR_CORRELATE 0x02
+#define PACKET_CONTROL_COALESCE               0x04
+#define PACKET_CONTROL_END_STREAM             0x08
+#define PACKET_CONTROL_SACK1                  0x10
+#define PACKET_CONTROL_SACK2                  0x20
+#define PACKET_CONTROL_SEND1                  0x40
+#define PACKET_CONTROL_SEND2                  0x80
+
+#define SACK_FLAGS_RESPONSE                   0x01
+#define SACK_FLAGS_SACK_MASK1                 0x02
+#define SACK_FLAGS_SACK_MASK2                 0x04
+#define SACK_FLAGS_SEND_MASK1                 0x08
+#define SACK_FLAGS_SEND_MASK2                 0x10
+
 #include "poppack.h"
 
 #endif
-- 
1.9.1

