From aada7a16baef2a3259bddfaa50d053105e4602ad Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 12 Dec 2016 10:39:16 +1100
Subject: [PATCH 10/47] dpnet/tests: Initial IDirectPlay8ThreadPool tests

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/dpnet/tests/Makefile.in |   3 +-
 dlls/dpnet/tests/thread.c    | 114 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 116 insertions(+), 1 deletion(-)
 create mode 100644 dlls/dpnet/tests/thread.c

diff --git a/dlls/dpnet/tests/Makefile.in b/dlls/dpnet/tests/Makefile.in
index 4b8cacd..62ef3f7 100644
--- a/dlls/dpnet/tests/Makefile.in
+++ b/dlls/dpnet/tests/Makefile.in
@@ -4,4 +4,5 @@ IMPORTS   = dxguid uuid dpnet ole32 oleaut32 version advapi32
 C_SRCS = \
 	address.c \
 	client.c \
-	server.c
+	server.c \
+	thread.c
diff --git a/dlls/dpnet/tests/thread.c b/dlls/dpnet/tests/thread.c
new file mode 100644
index 0000000..561178f
--- /dev/null
+++ b/dlls/dpnet/tests/thread.c
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2016 Alistair Leslie-Hughes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define WIN32_LEAN_AND_MEAN
+#include <stdio.h>
+
+#include <dplay8.h>
+#include "wine/test.h"
+
+static int cnt_thread_create = 0;
+static int cnt_thread_destroy = 0;
+
+static HRESULT WINAPI DirectPlayThreadHandler(void *context, DWORD message_id, void *buffer)
+{
+    switch(message_id)
+    {
+        case DPN_MSGID_CREATE_THREAD:
+            cnt_thread_create++;
+            break;
+        case DPN_MSGID_DESTROY_THREAD:
+            cnt_thread_destroy++;
+            break;
+        default:
+            trace("DirectPlayThreadHandler: 0x%08x\n", message_id);
+    }
+    return S_OK;
+}
+
+static void create_threadpool(void)
+{
+    HRESULT hr;
+    IDirectPlay8ThreadPool *pool1 = NULL;
+    IDirectPlay8ThreadPool *pool2 = NULL;
+    DWORD threadcnt = 10;
+
+    hr = CoCreateInstance( &CLSID_DirectPlay8ThreadPool, NULL, CLSCTX_ALL, &IID_IDirectPlay8ThreadPool, (void**)&pool1);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+
+    hr = CoCreateInstance( &CLSID_DirectPlay8ThreadPool, NULL, CLSCTX_ALL, &IID_IDirectPlay8ThreadPool, (void**)&pool2);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+
+    hr = IDirectPlay8ThreadPool_Initialize(pool1, NULL, NULL, 0);
+    todo_wine ok(hr == DPNERR_INVALIDPARAM, "got 0x%08x\n", hr);
+
+    hr = IDirectPlay8ThreadPool_Initialize(pool1, NULL, &DirectPlayThreadHandler, 0);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+
+    hr = IDirectPlay8ThreadPool_Initialize(pool2, NULL, &DirectPlayThreadHandler, 0);
+    todo_wine ok(hr == DPNERR_ALREADYINITIALIZED, "got 0x%08x\n", hr);
+
+    hr = IDirectPlay8ThreadPool_GetThreadCount(pool1, -1, &threadcnt, 0);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(threadcnt == 0, "got %d\n", threadcnt);
+
+    hr = IDirectPlay8ThreadPool_SetThreadCount(pool1, -1, 5, 0);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    todo_wine ok(cnt_thread_create == 5, "got %d\n", threadcnt);
+
+    hr = IDirectPlay8ThreadPool_SetThreadCount(pool2, -1, 5, 0);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    todo_wine ok(cnt_thread_create == 5, "got %d\n", threadcnt);
+
+    /* Thead count must be zero before DoWork can be called. */
+    hr = IDirectPlay8ThreadPool_DoWork(pool1, 100, 0);
+    todo_wine ok(hr == DPNERR_NOTREADY, "got 0x%08x\n", hr);
+
+    hr = IDirectPlay8ThreadPool_GetThreadCount(pool1, -1, &threadcnt, 0);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    todo_wine ok(threadcnt == 5, "got %d\n", threadcnt);
+
+    hr = IDirectPlay8ThreadPool_SetThreadCount(pool1, -1, 0, 0);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    todo_wine ok(cnt_thread_destroy == 5, "got %d\n", threadcnt);
+
+    hr = IDirectPlay8ThreadPool_DoWork(pool1, 100, 0);
+    ok(hr == DPN_OK, "got 0x%08x\n", hr);
+
+    hr = IDirectPlay8ThreadPool_Close(pool1, 0);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+
+    hr = IDirectPlay8ThreadPool_Close(pool2, 0);
+    todo_wine ok(hr == DPNERR_UNINITIALIZED, "got 0x%08x\n", hr);
+
+    IDirectPlay8ThreadPool_Release(pool1);
+    IDirectPlay8ThreadPool_Release(pool2);
+}
+
+START_TEST(thread)
+{
+    HRESULT hr;
+
+    hr = CoInitialize(0);
+    ok(hr == S_OK, "failed to init com\n");
+    if(hr != S_OK)
+        return;
+
+    create_threadpool();
+
+    CoUninitialize();
+}
-- 
1.9.1

