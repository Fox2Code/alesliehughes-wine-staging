From 5cfbb3fa9c5be8bcd9e2200e48dc8c16fc9284ae Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Sun, 24 Sep 2017 20:42:29 +1000
Subject: [PATCH] hnetcfg: Implement INetFwPolicy2 get_Rules

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/hnetcfg/hnetcfg_private.h |   1 +
 dlls/hnetcfg/policy.c          | 245 ++++++++++++++++++++++++++++++++++++++++-
 dlls/hnetcfg/tests/policy.c    |  37 +++++++
 3 files changed, 281 insertions(+), 2 deletions(-)

diff --git a/dlls/hnetcfg/hnetcfg_private.h b/dlls/hnetcfg/hnetcfg_private.h
index 812d970..5245883 100644
--- a/dlls/hnetcfg/hnetcfg_private.h
+++ b/dlls/hnetcfg/hnetcfg_private.h
@@ -26,6 +26,7 @@ enum type_id
     INetFwPolicy_tid,
     INetFwPolicy2_tid,
     INetFwProfile_tid,
+    INetFwRules_tid,
     last_tid
 };
 
diff --git a/dlls/hnetcfg/policy.c b/dlls/hnetcfg/policy.c
index 285ee0f..c2f3252 100644
--- a/dlls/hnetcfg/policy.c
+++ b/dlls/hnetcfg/policy.c
@@ -48,6 +48,7 @@ static inline fw_policy *impl_from_INetFwPolicy( INetFwPolicy *iface )
 typedef struct fw_policy2
 {
     INetFwPolicy2 INetFwPolicy2_iface;
+    INetFwRules   *fw_policy2_rules;
     LONG refs;
 } fw_policy2;
 
@@ -56,6 +57,224 @@ static inline fw_policy2 *impl_from_INetFwPolicy2( INetFwPolicy2 *iface )
     return CONTAINING_RECORD(iface, fw_policy2, INetFwPolicy2_iface);
 }
 
+typedef struct fw_rules
+{
+    INetFwRules INetFwRules_iface;
+    LONG refs;
+} fw_rules;
+
+static inline fw_rules *impl_from_INetFwRules( INetFwRules *iface )
+{
+    return CONTAINING_RECORD(iface, fw_rules, INetFwRules_iface);
+}
+
+static HRESULT WINAPI netfw_rules_QueryInterface(
+    INetFwRules *iface,
+    REFIID riid,
+    void **object)
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+
+    TRACE("%p %s %p\n", This, debugstr_guid( riid ), object );
+
+    if ( IsEqualGUID( riid, &IID_INetFwRules ) ||
+         IsEqualGUID( riid, &IID_IDispatch ) ||
+         IsEqualGUID( riid, &IID_IUnknown ) )
+    {
+        *object = iface;
+    }
+    else
+    {
+        FIXME("interface %s not implemented\n", debugstr_guid(riid));
+        return E_NOINTERFACE;
+    }
+    INetFwRules_AddRef( iface );
+    return S_OK;
+}
+
+static ULONG WINAPI netfw_rules_AddRef(
+    INetFwRules *iface )
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+    return InterlockedIncrement( &This->refs );
+}
+
+static ULONG WINAPI netfw_rules_Release(
+    INetFwRules *iface )
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+    LONG refs = InterlockedDecrement( &This->refs );
+    if (!refs)
+    {
+        TRACE("destroying %p\n", This);
+        HeapFree( GetProcessHeap(), 0, This );
+    }
+    return refs;
+}
+
+static HRESULT WINAPI netfw_rules_GetTypeInfoCount(
+    INetFwRules *iface,
+    UINT *pctinfo )
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+
+    TRACE("%p %p\n", This, pctinfo);
+    *pctinfo = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI netfw_rules_GetTypeInfo(
+    INetFwRules *iface,
+    UINT iTInfo,
+    LCID lcid,
+    ITypeInfo **ppTInfo)
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+
+    TRACE("%p %u %u %p\n", This, iTInfo, lcid, ppTInfo);
+    return get_typeinfo( INetFwRules_tid, ppTInfo );
+}
+
+static HRESULT WINAPI netfw_rules_GetIDsOfNames(
+    INetFwRules *iface,
+    REFIID riid,
+    LPOLESTR *rgszNames,
+    UINT cNames,
+    LCID lcid,
+    DISPID *rgDispId)
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+    ITypeInfo *typeinfo;
+    HRESULT hr;
+
+    TRACE("%p %s %p %u %u %p\n", This, debugstr_guid(riid), rgszNames, cNames, lcid, rgDispId);
+
+    hr = get_typeinfo( INetFwRules_tid, &typeinfo );
+    if (SUCCEEDED(hr))
+    {
+        hr = ITypeInfo_GetIDsOfNames( typeinfo, rgszNames, cNames, rgDispId );
+        ITypeInfo_Release( typeinfo );
+    }
+    return hr;
+}
+
+static HRESULT WINAPI netfw_rules_Invoke(
+    INetFwRules *iface,
+    DISPID dispIdMember,
+    REFIID riid,
+    LCID lcid,
+    WORD wFlags,
+    DISPPARAMS *pDispParams,
+    VARIANT *pVarResult,
+    EXCEPINFO *pExcepInfo,
+    UINT *puArgErr)
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+    ITypeInfo *typeinfo;
+    HRESULT hr;
+
+    TRACE("%p %d %s %d %d %p %p %p %p\n", This, dispIdMember, debugstr_guid(riid),
+          lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+
+    hr = get_typeinfo( INetFwRules_tid, &typeinfo );
+    if (SUCCEEDED(hr))
+    {
+        hr = ITypeInfo_Invoke( typeinfo, &This->INetFwRules_iface, dispIdMember,
+                               wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr );
+        ITypeInfo_Release( typeinfo );
+    }
+    return hr;
+}
+
+static HRESULT WINAPI netfw_rules_get_Count(
+    INetFwRules *iface,
+    LONG *count)
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+
+    FIXME("%p, %p\n", This, count);
+
+    if (count)
+        *count = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI netfw_rules_Add(
+    INetFwRules *iface,
+    INetFwRule *rule)
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+
+    FIXME("%p, %p\n", This, rule);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI netfw_rules_Remove(
+    INetFwRules *iface,
+    BSTR name)
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+
+    FIXME("%p, %s\n", This, debugstr_w(name));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI netfw_rules_Item(
+    INetFwRules *iface,
+    BSTR name,
+    INetFwRule **rule)
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+
+    FIXME("%p, %s, %p\n", This, debugstr_w(name), rule);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI netfw_rules_get__NewEnum(
+    INetFwRules *iface,
+    IUnknown **newEnum)
+{
+    fw_rules *This = impl_from_INetFwRules( iface );
+
+    FIXME("%p, %p\n", This, newEnum);
+    return E_NOTIMPL;
+}
+
+static const struct INetFwRulesVtbl fw_rules_vtbl =
+{
+    netfw_rules_QueryInterface,
+    netfw_rules_AddRef,
+    netfw_rules_Release,
+    netfw_rules_GetTypeInfoCount,
+    netfw_rules_GetTypeInfo,
+    netfw_rules_GetIDsOfNames,
+    netfw_rules_Invoke,
+    netfw_rules_get_Count,
+    netfw_rules_Add,
+    netfw_rules_Remove,
+    netfw_rules_Item,
+    netfw_rules_get__NewEnum
+};
+
+static HRESULT create_INetFwRules(INetFwRules **object)
+{
+    fw_rules *rules;
+
+    TRACE("(%p)\n", object);
+
+    rules = HeapAlloc( GetProcessHeap(), 0, sizeof(*rules) );
+    if (!rules) return E_OUTOFMEMORY;
+
+    rules->INetFwRules_iface.lpVtbl = &fw_rules_vtbl;
+    rules->refs = 1;
+
+    *object = &rules->INetFwRules_iface;
+
+    TRACE("returning iface %p\n", *object);
+    return S_OK;
+}
+
 static ULONG WINAPI fw_policy_AddRef(
     INetFwPolicy *iface )
 {
@@ -238,6 +457,11 @@ static HRESULT WINAPI fwpolicy2_QueryInterface(INetFwPolicy2 *iface, REFIID riid
     {
         *out = iface;
     }
+    else if( IsEqualGUID( riid, &IID_INetFwRules ) )
+    {
+        TRACE("INetFwRules not supported\n");
+        return E_NOINTERFACE;
+    }
     else
     {
         FIXME("interface %s not implemented\n", debugstr_guid(riid));
@@ -259,6 +483,7 @@ static ULONG WINAPI fwpolicy2_Release(INetFwPolicy2 *iface)
     LONG refs = InterlockedDecrement( &fw_policy->refs );
     if (!refs)
     {
+        INetFwRules_Release(fw_policy->fw_policy2_rules);
         TRACE("destroying %p\n", fw_policy);
         HeapFree( GetProcessHeap(), 0, fw_policy );
     }
@@ -411,8 +636,18 @@ static HRESULT WINAPI fwpolicy2_get_Rules(INetFwPolicy2 *iface, INetFwRules **ru
 {
     fw_policy2 *This = impl_from_INetFwPolicy2( iface );
 
-    FIXME("%p %p\n", This, rules);
-    return E_NOTIMPL;
+    TRACE("%p %p\n", This, rules);
+
+    if(!rules)
+        return E_POINTER;
+
+    if(rules)
+    {
+        *rules = This->fw_policy2_rules;
+        INetFwRules_AddRef(This->fw_policy2_rules);
+    }
+
+    return S_OK;
 }
 
 static HRESULT WINAPI fwpolicy2_get_ServiceRestriction(INetFwPolicy2 *iface, INetFwServiceRestriction **ServiceRestriction)
@@ -542,6 +777,12 @@ HRESULT NetFwPolicy2_create( IUnknown *outer, void **obj )
 
     *obj = &fp->INetFwPolicy2_iface;
 
+    if (FAILED(create_INetFwRules(&fp->fw_policy2_rules)))
+    {
+        HeapFree( GetProcessHeap(), 0, fp );
+        return E_OUTOFMEMORY;
+    }
+
     TRACE("returning iface %p\n", *obj);
     return S_OK;
 }
diff --git a/dlls/hnetcfg/tests/policy.c b/dlls/hnetcfg/tests/policy.c
index a3ed4b2..7b5bef0 100644
--- a/dlls/hnetcfg/tests/policy.c
+++ b/dlls/hnetcfg/tests/policy.c
@@ -28,6 +28,41 @@
 
 #include "netfw.h"
 
+static void test_policy2_rules(INetFwPolicy2 *policy2)
+{
+    HRESULT hr;
+    INetFwRules *rules, *rules2;
+    INetFwServiceRestriction *restriction;
+
+    hr = INetFwPolicy2_QueryInterface(policy2, &IID_INetFwRules, (void**)&rules);
+    ok(hr == E_NOINTERFACE, "got 0x%08x\n", hr);
+
+    hr = INetFwPolicy2_get_Rules(policy2, &rules);
+    ok(hr == S_OK, "got %08x\n", hr);
+
+    hr = INetFwPolicy2_get_Rules(policy2, &rules2);
+    ok(hr == S_OK, "got %08x\n", hr);
+    ok(rules == rules2, "Different pointers\n");
+
+    hr = INetFwPolicy2_get_ServiceRestriction(policy2, &restriction);
+    todo_wine ok(hr == S_OK, "got %08x\n", hr);
+    if(hr == S_OK)
+    {
+        INetFwRules *rules3;
+
+        hr = INetFwServiceRestriction_get_Rules(restriction, &rules3);
+        ok(hr == S_OK, "got %08x\n", hr);
+        ok(rules != rules3, "same pointers\n");
+
+        if(rules3)
+            INetFwRules_Release(rules3);
+        INetFwServiceRestriction_Release(restriction);
+    }
+
+    INetFwRules_Release(rules);
+    INetFwRules_Release(rules2);
+}
+
 static void test_interfaces(void)
 {
     INetFwMgr *manager;
@@ -57,6 +92,8 @@ static void test_interfaces(void)
             &IID_INetFwPolicy2, (void**)&policy2);
     if(hr == S_OK)
     {
+        test_policy2_rules(policy2);
+
         INetFwPolicy2_Release(policy2);
     }
     else
-- 
1.9.1

