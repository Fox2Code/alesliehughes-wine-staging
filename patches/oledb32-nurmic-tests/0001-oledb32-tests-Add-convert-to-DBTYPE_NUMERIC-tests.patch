From 40a08f2476dab01ca237215ac6f5144df3a3bbb8 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 17 Mar 2017 14:02:31 +1100
Subject: [PATCH] oledb32/tests: Add convert to DBTYPE_NUMERIC tests

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/oledb32/tests/convert.c | 147 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 147 insertions(+)

diff --git a/dlls/oledb32/tests/convert.c b/dlls/oledb32/tests/convert.c
index b8b3c6f..4e49058 100644
--- a/dlls/oledb32/tests/convert.c
+++ b/dlls/oledb32/tests/convert.c
@@ -3264,6 +3264,152 @@ static void test_converttoiunknown(void)
     ok(dst_len == 44, "got %ld\n", dst_len);
 }
 
+#define test_numberic_val(dst, array) _test_numberic_val(__LINE__, dst, array);
+static inline void _test_numberic_val(unsigned line, DB_NUMERIC *dst, BYTE *array)
+{
+    int same = !memcmp(dst->val, array, sizeof(dst->val));
+    ok_(__FILE__,line) (same, "Invalid byte array\n");
+    if(!same)
+    {
+        int i;
+        for(i=0; i < sizeof(dst->val); i++)
+            ok_(__FILE__,line) (dst->val[i] == array[i], " byte %d got 0x%02x\n", i, dst->val[i]);
+    }
+}
+
+static inline void set_numberic_array(BYTE *dst,
+                                 BYTE x0, BYTE x1, BYTE x2,  BYTE x3,  BYTE x4,  BYTE x5,  BYTE x6,
+                                 BYTE x7, BYTE x8, BYTE x9,  BYTE x10, BYTE x11, BYTE x12, BYTE x13,
+                                 BYTE x14, BYTE x15)
+{
+    dst[0]  = x0;  dst[1]  = x1;  dst[2]  = x2;  dst[3]  = x3;
+    dst[4]  = x4;  dst[5]  = x5;  dst[6]  = x6;  dst[7]  = x7;
+    dst[8]  = x8;  dst[9]  = x9;  dst[10] = x10; dst[11] = x11;
+    dst[12] = x12; dst[13] = x13; dst[14] = x14; dst[15] = x15;
+}
+
+static void test_converttonumeric(void)
+{
+    HRESULT hr;
+    DBSTATUS dst_status;
+    DBLENGTH dst_len;
+    DB_NUMERIC dst;
+    BYTE src[20];
+    static WCHAR strW[] = {'1','2','3','.','4','5',0};
+    static WCHAR largeW[] = {'1','2','3','4','5','6','7','8','9','0',0};
+    BSTR bstr;
+    FLOAT fvalue = 543.21f;
+    VARIANT_BOOL boolean = VARIANT_TRUE;
+    LARGE_INTEGER i8;
+    BYTE array[16];
+
+    *(INT *)src = 4098;
+    dst_len = 0x1234;
+    dst.scale = 30;
+    memset(dst.val, 0xfe, sizeof(dst.val));
+    hr = IDataConvert_DataConvert(convert, DBTYPE_I4, DBTYPE_NUMERIC, 0, &dst_len, src, &dst, sizeof(dst), 0, &dst_status, 10, 0, 0);
+    todo_wine ok(hr == S_OK, "got %08x\n", hr);
+    todo_wine ok(dst_status == DBSTATUS_S_OK, "got %08x\n", dst_status);
+    todo_wine ok(dst_len == sizeof(dst), "got %ld\n", dst_len);
+    todo_wine ok(dst.precision == 10, "returned %d\n", dst.precision);
+    todo_wine ok(dst.scale == 0, "returned %d\n", dst.scale);
+    todo_wine ok(dst.sign == 1, "returned %d\n", dst.sign);
+    set_numberic_array(array, 0x02, 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
+    todo_wine test_numberic_val(&dst, array);
+
+    i8.QuadPart = 12345;
+    dst_len = 0x1234;
+    dst.scale = 30;
+    memset(dst.val, 0xfe, sizeof(dst.val));
+    hr = IDataConvert_DataConvert(convert, DBTYPE_I8, DBTYPE_NUMERIC, sizeof(i8), &dst_len, &i8, &dst, sizeof(dst), 0, &dst_status, 10, 0, 0);
+    todo_wine ok(hr == S_OK, "got %08x\n", hr);
+    todo_wine ok(dst_status == DBSTATUS_S_OK, "got %08x\n", dst_status);
+    todo_wine ok(dst_len == sizeof(dst), "got %ld\n", dst_len);
+    todo_wine ok(dst.precision == 10, "returned %d\n", dst.precision);
+    todo_wine ok(dst.scale == 0, "returned %d\n", dst.scale);
+    todo_wine ok(dst.sign == 1, "returned %d\n", dst.sign);
+    set_numberic_array(array, 0x39, 0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
+    todo_wine test_numberic_val(&dst, array);
+
+    dst_len = 0x1234;
+    dst.scale = 30;
+    dst.sign = 1;
+    memset(dst.val, 0xfe, sizeof(dst.val));
+    hr = IDataConvert_DataConvert(convert, DBTYPE_BOOL, DBTYPE_NUMERIC, sizeof(boolean), &dst_len, &boolean, &dst, sizeof(dst), 0, &dst_status, 10, 0, 0);
+    todo_wine ok(hr == S_OK, "got %08x\n", hr);
+    todo_wine ok(dst_status == DBSTATUS_S_OK, "got %08x\n", dst_status);
+    todo_wine ok(dst_len == sizeof(dst), "got %ld\n", dst_len);
+    todo_wine ok(dst.precision == 10, "returned %d\n", dst.precision);
+    todo_wine ok(dst.scale == 0, "returned %d\n", dst.scale);
+    todo_wine ok(dst.sign == 0, "returned %d\n", dst.sign);
+    set_numberic_array(array, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
+    todo_wine test_numberic_val(&dst, array);
+
+    dst_len = 0x1234;
+    dst.scale = 30;
+    dst.sign = 0;
+    memset(dst.val, 0xfe, sizeof(dst.val));
+    hr = IDataConvert_DataConvert(convert, DBTYPE_R4, DBTYPE_NUMERIC, sizeof(fvalue), &dst_len, &fvalue, &dst, sizeof(dst), 0, &dst_status, 10, 0, 0);
+    todo_wine ok(hr == S_OK, "got %08x\n", hr);
+    todo_wine ok(dst_status == DBSTATUS_S_OK, "got %08x\n", dst_status);
+    todo_wine ok(dst_len == sizeof(dst), "got %ld\n", dst_len);
+    todo_wine ok(dst.precision == 10, "returned %d\n", dst.precision);
+    todo_wine ok(dst.scale == 0, "returned %d\n", dst.scale);
+    todo_wine ok(dst.sign == 1, "returned %d\n", dst.sign);
+    set_numberic_array(array, 0x1f, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
+    todo_wine test_numberic_val(&dst, array);
+
+    dst_len = 0x1234;
+    dst.scale = 30;
+    dst.sign = 0;
+    memset(dst.val, 0xfe, sizeof(dst.val));
+    hr = IDataConvert_DataConvert(convert, DBTYPE_WSTR, DBTYPE_NUMERIC, sizeof(strW), &dst_len, strW, &dst, sizeof(dst), 0, &dst_status, 10, 0, 0);
+    todo_wine ok(hr == S_OK, "got %08x\n", hr);
+    todo_wine ok(dst_status == DBSTATUS_S_OK, "got %08x\n", dst_status);
+    todo_wine ok(dst_len == sizeof(dst), "got %ld\n", dst_len);
+    todo_wine ok(dst.precision == 10, "returned %d\n", dst.precision);
+    todo_wine ok(dst.scale == 0, "returned %d\n", dst.scale);
+    todo_wine ok(dst.sign == 1, "returned %d\n", dst.sign);
+    set_numberic_array(array, 0x7b, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
+    todo_wine test_numberic_val(&dst, array);
+
+    bstr = SysAllocString(strW);
+    *(BSTR *)src = bstr;
+    dst_status = 0;
+    dst.scale = 30;
+    dst.sign = 0;
+    dst_len = sizeof(strW);
+    memset(dst.val, 0xfe, sizeof(dst.val));
+    hr = IDataConvert_DataConvert(convert, DBTYPE_BSTR, DBTYPE_NUMERIC, 0, &dst_len, src, &dst, sizeof(dst), 0, &dst_status, 10, 0, 0);
+    todo_wine ok(hr == S_OK, "got %08x\n", hr);
+    todo_wine ok(dst_status == DBSTATUS_S_OK, "got %08x\n", dst_status);
+    todo_wine ok(dst_len == sizeof(dst), "got %ld\n", dst_len);
+    todo_wine ok(dst.precision == 10, "returned %d\n", dst.precision);
+    todo_wine ok(dst.scale == 0, "returned %d\n", dst.scale);
+    todo_wine ok(dst.sign == 1, "returned %d\n", dst.sign);
+    SysFreeString(bstr);
+    set_numberic_array(array, 0x7b, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
+    todo_wine test_numberic_val(&dst, array);
+
+    bstr = SysAllocString(largeW);
+    *(BSTR *)src = bstr;
+    dst_status = 0;
+    dst.scale = 30;
+    dst.sign = 0;
+    dst_len = sizeof(largeW);
+    memset(dst.val, 0xfe, sizeof(dst.val));
+    hr = IDataConvert_DataConvert(convert, DBTYPE_BSTR, DBTYPE_NUMERIC, 0, &dst_len, src, &dst, sizeof(dst), 0, &dst_status, 10, 0, 0);
+    todo_wine ok(hr == S_OK, "got %08x\n", hr);
+    todo_wine ok(dst_status == DBSTATUS_S_OK, "got %08x\n", dst_status);
+    todo_wine ok(dst_len == sizeof(dst), "got %ld\n", dst_len);
+    todo_wine ok(dst.precision == 10, "returned %d\n", dst.precision);
+    todo_wine ok(dst.scale == 0, "returned %d\n", dst.scale);
+    todo_wine ok(dst.sign == 1, "returned %d\n", dst.sign);
+    SysFreeString(bstr);
+    set_numberic_array(array, 0xd2, 0x02, 0x96, 0x49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
+    todo_wine test_numberic_val(&dst, array);
+}
+
 START_TEST(convert)
 {
     HRESULT hr;
@@ -3304,6 +3450,7 @@ START_TEST(convert)
     test_getconversionsize();
     test_converttotimestamp();
     test_converttoiunknown();
+    test_converttonumeric();
 
     IDataConvert_Release(convert);
 
-- 
1.9.1

