From 71c1df754bd1d49ec4b10af8269877b96f86839d Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Fri, 15 Jul 2016 10:35:36 +1000
Subject: [PATCH 4/4] hnetcfg: Add stubbed INetFwPolicy2 interface

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
---
 dlls/hnetcfg/apps.c            |   1 +
 dlls/hnetcfg/hnetcfg.c         |   5 +
 dlls/hnetcfg/hnetcfg_private.h |   2 +
 dlls/hnetcfg/policy.c          | 334 +++++++++++++++++++++++++++++++++++++++++
 4 files changed, 342 insertions(+)

diff --git a/dlls/hnetcfg/apps.c b/dlls/hnetcfg/apps.c
index ea6d411..2b8d78c 100644
--- a/dlls/hnetcfg/apps.c
+++ b/dlls/hnetcfg/apps.c
@@ -111,6 +111,7 @@ static REFIID tid_id[] =
     &IID_INetFwOpenPort,
     &IID_INetFwOpenPorts,
     &IID_INetFwPolicy,
+    &IID_INetFwPolicy2,
     &IID_INetFwProfile
 };
 
diff --git a/dlls/hnetcfg/hnetcfg.c b/dlls/hnetcfg/hnetcfg.c
index fadd367..e56dbab 100644
--- a/dlls/hnetcfg/hnetcfg.c
+++ b/dlls/hnetcfg/hnetcfg.c
@@ -113,6 +113,7 @@ static const struct IClassFactoryVtbl hnetcfg_cf_vtbl =
 static hnetcfg_cf fw_manager_cf = { { &hnetcfg_cf_vtbl }, NetFwMgr_create };
 static hnetcfg_cf fw_app_cf = { { &hnetcfg_cf_vtbl }, NetFwAuthorizedApplication_create };
 static hnetcfg_cf fw_openport_cf = { { &hnetcfg_cf_vtbl }, NetFwOpenPort_create };
+static hnetcfg_cf fw_policy2_cf = { { &hnetcfg_cf_vtbl }, NetFwPolicy2_create };
 
 BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID reserved)
 {
@@ -151,6 +152,10 @@ HRESULT WINAPI DllGetClassObject( REFCLSID rclsid, REFIID iid, LPVOID *ppv )
     {
        cf = &fw_openport_cf.IClassFactory_iface;
     }
+    else if (IsEqualGUID( rclsid, &CLSID_NetFwPolicy2 ))
+    {
+       cf = &fw_policy2_cf.IClassFactory_iface;
+    }
 
     if (!cf) return CLASS_E_CLASSNOTAVAILABLE;
     return IClassFactory_QueryInterface( cf, iid, ppv );
diff --git a/dlls/hnetcfg/hnetcfg_private.h b/dlls/hnetcfg/hnetcfg_private.h
index bb3f3aa..812d970 100644
--- a/dlls/hnetcfg/hnetcfg_private.h
+++ b/dlls/hnetcfg/hnetcfg_private.h
@@ -24,6 +24,7 @@ enum type_id
     INetFwOpenPort_tid,
     INetFwOpenPorts_tid,
     INetFwPolicy_tid,
+    INetFwPolicy2_tid,
     INetFwProfile_tid,
     last_tid
 };
@@ -33,6 +34,7 @@ void release_typelib(void) DECLSPEC_HIDDEN;
 
 HRESULT NetFwMgr_create(IUnknown *, LPVOID *) DECLSPEC_HIDDEN;
 HRESULT NetFwPolicy_create(IUnknown *, LPVOID *) DECLSPEC_HIDDEN;
+HRESULT NetFwPolicy2_create(IUnknown *, void **) DECLSPEC_HIDDEN;
 HRESULT NetFwProfile_create(IUnknown *, LPVOID *) DECLSPEC_HIDDEN;
 HRESULT NetFwAuthorizedApplication_create(IUnknown *, LPVOID *) DECLSPEC_HIDDEN;
 HRESULT NetFwAuthorizedApplications_create(IUnknown *, LPVOID *) DECLSPEC_HIDDEN;
diff --git a/dlls/hnetcfg/policy.c b/dlls/hnetcfg/policy.c
index e340ffb..a8376ba 100644
--- a/dlls/hnetcfg/policy.c
+++ b/dlls/hnetcfg/policy.c
@@ -214,3 +214,337 @@ HRESULT NetFwPolicy_create( IUnknown *pUnkOuter, LPVOID *ppObj )
     TRACE("returning iface %p\n", *ppObj);
     return S_OK;
 }
+
+/******/
+
+typedef struct fw_policy2
+{
+    INetFwPolicy2 INetFwPolicy2_iface;
+    LONG refs;
+} fw_policy2;
+
+static inline fw_policy2 *impl_from_INetFwPolicy2( INetFwPolicy2 *iface )
+{
+    return CONTAINING_RECORD(iface, fw_policy2, INetFwPolicy2_iface);
+}
+
+static HRESULT WINAPI fwpolicy2_QueryInterface(INetFwPolicy2 *iface, REFIID riid, void **out)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    TRACE("%p %s %p\n", This, debugstr_guid( riid ), out );
+
+    if ( IsEqualGUID( riid, &IID_INetFwPolicy2 ) ||
+         IsEqualGUID( riid, &IID_IDispatch ) ||
+         IsEqualGUID( riid, &IID_IUnknown ) )
+    {
+        *out = iface;
+    }
+    else
+    {
+        FIXME("interface %s not implemented\n", debugstr_guid(riid));
+        return E_NOINTERFACE;
+    }
+    INetFwPolicy2_AddRef( iface );
+    return S_OK;
+}
+
+static ULONG WINAPI fwpolicy2_AddRef(INetFwPolicy2 *iface)
+{
+    fw_policy2 *fw_policy = impl_from_INetFwPolicy2( iface );
+    return InterlockedIncrement( &fw_policy->refs );
+}
+
+static ULONG WINAPI fwpolicy2_Release(INetFwPolicy2 *iface)
+{
+    fw_policy2 *fw_policy = impl_from_INetFwPolicy2( iface );
+    LONG refs = InterlockedDecrement( &fw_policy->refs );
+    if (!refs)
+    {
+        TRACE("destroying %p\n", fw_policy);
+        HeapFree( GetProcessHeap(), 0, fw_policy );
+    }
+    return refs;
+}
+
+static HRESULT WINAPI fwpolicy2_GetTypeInfoCount(INetFwPolicy2 *iface, UINT *pctinfo)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    TRACE("%p %p\n", This, pctinfo);
+    *pctinfo = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI fwpolicy2_GetTypeInfo(INetFwPolicy2 *iface, UINT iTInfo, LCID lcid, ITypeInfo **info)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    TRACE("%p %u %u %p\n", This, iTInfo, lcid, info);
+    return get_typeinfo( INetFwPolicy2_tid, info );
+}
+
+static HRESULT WINAPI fwpolicy2_GetIDsOfNames(INetFwPolicy2 *iface, REFIID riid, LPOLESTR *rgszNames,
+                        UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+    ITypeInfo *typeinfo;
+    HRESULT hr;
+
+    TRACE("%p %s %p %u %u %p\n", This, debugstr_guid(riid), rgszNames, cNames, lcid, rgDispId);
+
+    hr = get_typeinfo( INetFwPolicy2_tid, &typeinfo );
+    if (SUCCEEDED(hr))
+    {
+        hr = ITypeInfo_GetIDsOfNames( typeinfo, rgszNames, cNames, rgDispId );
+        ITypeInfo_Release( typeinfo );
+    }
+    return hr;
+}
+
+static HRESULT WINAPI fwpolicy2_Invoke(INetFwPolicy2 *iface, DISPID dispIdMember, REFIID riid, LCID lcid,
+                WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+    ITypeInfo *typeinfo;
+    HRESULT hr;
+
+    TRACE("%p %d %s %d %d %p %p %p %p\n", This, dispIdMember, debugstr_guid(riid),
+          lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+
+    hr = get_typeinfo( INetFwPolicy2_tid, &typeinfo );
+    if (SUCCEEDED(hr))
+    {
+        hr = ITypeInfo_Invoke( typeinfo, &This->INetFwPolicy2_iface, dispIdMember,
+                               wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr );
+        ITypeInfo_Release( typeinfo );
+    }
+    return hr;
+}
+
+static HRESULT WINAPI fwpolicy2_get_CurrentProfileTypes(INetFwPolicy2 *iface, LONG *profile)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %p\n", This, profile);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_FirewallEnabled(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT_BOOL *enabled)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %p\n", This, profileType, enabled);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_put_FirewallEnabled(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT_BOOL enabled)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %d\n", This, profileType, enabled);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_ExcludedInterfaces(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT *interfaces)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %p\n", This, profileType, interfaces);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_put_ExcludedInterfaces(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT interfaces)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d\n", This, profileType);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_BlockAllInboundTraffic(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT_BOOL *block)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %p\n", This, profileType, block);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_put_BlockAllInboundTraffic(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT_BOOL block)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %d\n", This, profileType, block);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_NotificationsDisabled(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT_BOOL *disabled)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %p\n", This, profileType, disabled);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_put_NotificationsDisabled(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT_BOOL disabled)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %d\n", This, profileType, disabled);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_UnicastResponsesToMulticastBroadcastDisabled(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT_BOOL *disabled)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %p\n", This, profileType, disabled);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_put_UnicastResponsesToMulticastBroadcastDisabled(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, VARIANT_BOOL disabled)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %d\n", This, profileType, disabled);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_Rules(INetFwPolicy2 *iface, INetFwRules **rules)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %p\n", This, rules);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_ServiceRestriction(INetFwPolicy2 *iface, INetFwServiceRestriction **ServiceRestriction)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %p\n", This, ServiceRestriction);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_EnableRuleGroup(INetFwPolicy2 *iface, LONG bitmask, BSTR group, VARIANT_BOOL enable)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %s %d\n", This, bitmask, debugstr_w(group), enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_IsRuleGroupEnabled(INetFwPolicy2 *iface, LONG bitmask, BSTR group, VARIANT_BOOL *enabled)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %s %p\n", This, bitmask, debugstr_w(group), enabled);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_RestoreLocalFirewallDefaults(INetFwPolicy2 *iface)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_DefaultInboundAction(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, NET_FW_ACTION *action)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %p\n", This, profileType, action);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_put_DefaultInboundAction(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, NET_FW_ACTION action)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %d\n", This, profileType, action);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_DefaultOutboundAction(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, NET_FW_ACTION *action)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %p\n", This, profileType, action);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_put_DefaultOutboundAction(INetFwPolicy2 *iface, NET_FW_PROFILE_TYPE2 profileType, NET_FW_ACTION action)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %d %d\n", This, profileType, action);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_IsRuleGroupCurrentlyEnabled(INetFwPolicy2 *iface, BSTR group, VARIANT_BOOL *enabled)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %s %p\n", This, debugstr_w(group), enabled);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI fwpolicy2_get_LocalPolicyModifyState(INetFwPolicy2 *iface, NET_FW_MODIFY_STATE *modifyState)
+{
+    fw_policy2 *This = impl_from_INetFwPolicy2( iface );
+
+    FIXME("%p %p\n", This, modifyState);
+    return E_NOTIMPL;
+}
+
+static const struct INetFwPolicy2Vtbl fw_policy2_vtbl =
+{
+    fwpolicy2_QueryInterface,
+    fwpolicy2_AddRef,
+    fwpolicy2_Release,
+    fwpolicy2_GetTypeInfoCount,
+    fwpolicy2_GetTypeInfo,
+    fwpolicy2_GetIDsOfNames,
+    fwpolicy2_Invoke,
+    fwpolicy2_get_CurrentProfileTypes,
+    fwpolicy2_get_FirewallEnabled,
+    fwpolicy2_put_FirewallEnabled,
+    fwpolicy2_get_ExcludedInterfaces,
+    fwpolicy2_put_ExcludedInterfaces,
+    fwpolicy2_get_BlockAllInboundTraffic,
+    fwpolicy2_put_BlockAllInboundTraffic,
+    fwpolicy2_get_NotificationsDisabled,
+    fwpolicy2_put_NotificationsDisabled,
+    fwpolicy2_get_UnicastResponsesToMulticastBroadcastDisabled,
+    fwpolicy2_put_UnicastResponsesToMulticastBroadcastDisabled,
+    fwpolicy2_get_Rules,
+    fwpolicy2_get_ServiceRestriction,
+    fwpolicy2_EnableRuleGroup,
+    fwpolicy2_IsRuleGroupEnabled,
+    fwpolicy2_RestoreLocalFirewallDefaults,
+    fwpolicy2_get_DefaultInboundAction,
+    fwpolicy2_put_DefaultInboundAction,
+    fwpolicy2_get_DefaultOutboundAction,
+    fwpolicy2_put_DefaultOutboundAction,
+    fwpolicy2_get_IsRuleGroupCurrentlyEnabled,
+    fwpolicy2_get_LocalPolicyModifyState
+};
+
+HRESULT NetFwPolicy2_create( IUnknown *outer, void **obj )
+{
+    fw_policy2 *fp;
+
+    TRACE("(%p,%p)\n", outer, obj);
+
+    fp = HeapAlloc( GetProcessHeap(), 0, sizeof(*fp) );
+    if (!fp) return E_OUTOFMEMORY;
+
+    fp->INetFwPolicy2_iface.lpVtbl = &fw_policy2_vtbl;
+    fp->refs = 1;
+
+    *obj = &fp->INetFwPolicy2_iface;
+
+    TRACE("returning iface %p\n", *obj);
+    return S_OK;
+}
-- 
1.9.1

