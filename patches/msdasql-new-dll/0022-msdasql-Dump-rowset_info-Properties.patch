From 35fa3a3bd3242dc6dffe037e9050afd1d81a6611 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 29 Oct 2020 11:08:34 +1100
Subject: msdasql: Dump rowset_info Properties


diff --git a/dlls/msdasql/session.c b/dlls/msdasql/session.c
index a563fe12424..5470383aff9 100644
--- a/dlls/msdasql/session.c
+++ b/dlls/msdasql/session.c
@@ -25,6 +25,7 @@
 #include "objbase.h"
 #include "rpcproxy.h"
 #include "msdasc.h"
+#include "oledberr.h"
 #include "wine/heap.h"
 #include "wine/debug.h"
 
@@ -526,11 +527,62 @@ static ULONG WINAPI rowset_info_Release(IRowsetInfo *iface)
 }
 
 static HRESULT WINAPI rowset_info_GetProperties(IRowsetInfo *iface, const ULONG count,
-        const DBPROPIDSET propertyidsets[], ULONG *out_count, DBPROPSET **propertysets)
+        const DBPROPIDSET propertyidsets[], ULONG *out_count, DBPROPSET **propertysets1)
 {
     struct msdasql_rowset *rowset = impl_from_IRowsetInfo( iface );
-    FIXME("%p, %ld, %p, %p, %p\n", rowset, count, propertyidsets, out_count, propertysets);
-    return E_NOTIMPL;
+    int i, j;
+    DBPROPSET *propertysets;
+
+    FIXME("%p, %d, %p, %p, %p\n", rowset, count, propertyidsets, out_count, propertysets1);
+
+    propertysets = CoTaskMemAlloc(count * sizeof(DBPROPSET));
+    if (!propertysets)
+        return E_OUTOFMEMORY;
+
+    memset(propertysets, 0, count * sizeof(DBPROPSET));
+    for (i=0; i < count; i++)
+    {
+        FIXME("Property Set %d\n", i);
+        FIXME("  cPropertyIDs:  %d\n", propertyidsets[i].cPropertyIDs);
+        FIXME("  guidPropertySet: %s\n", debugstr_guid(&propertyidsets[i].guidPropertySet) );
+
+        propertysets[i].rgProperties = CoTaskMemAlloc(propertyidsets[i].cPropertyIDs * sizeof(DBPROP));
+        memset(propertysets[i].rgProperties, 0, propertyidsets[i].cPropertyIDs * sizeof(DBPROP));
+
+        propertysets[i].cProperties = propertyidsets[i].cPropertyIDs;
+        for (j=0; j < propertyidsets[i].cPropertyIDs; j++)
+        {
+            FIXME("  rgPropertyIDs[%d]: 0x%08x\n", j, propertyidsets[i].rgPropertyIDs[j]);
+            switch(propertyidsets[i].rgPropertyIDs[j])
+            {
+                case DBPROP_CANHOLDROWS:
+                    V_VT(&propertysets[i].rgProperties[j].vValue) = VT_BOOL;
+                    V_BOOL(&propertysets[i].rgProperties[j].vValue) = VARIANT_FALSE;
+                    break;
+                case DBPROP_CANSCROLLBACKWARDS:
+                    V_VT(&propertysets[i].rgProperties[j].vValue) = VT_I4;
+                    V_I4(&propertysets[i].rgProperties[j].vValue) = 0;
+                    break;
+                case DBPROP_UPDATABILITY:
+                case DBPROP_IRowsetUpdate:
+                case DBPROP_IRowsetResynch:
+                case DBPROP_IConnectionPointContainer:
+                    case DBPROP_REMOVEDELETED:
+                    V_VT(&propertysets[i].rgProperties[j].vValue) = VT_BOOL;
+                    V_BOOL(&propertysets[i].rgProperties[j].vValue) = VARIANT_FALSE;
+                    break;
+                case DBPROP_BOOKMARKSKIPPED:
+                case DBPROP_IRowsetCurrentIndex:
+                default:
+                    V_VT(&propertysets[i].rgProperties[j].vValue) = VT_EMPTY;
+                    propertysets[i].rgProperties[j].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
+            }
+        }
+    }
+
+    *propertysets1 = propertysets;
+    *out_count = count;
+    return DB_S_ERRORSOCCURRED;
 }
 
 static HRESULT WINAPI rowset_info_GetReferencedRowset(IRowsetInfo *iface, DBORDINAL ordinal,
